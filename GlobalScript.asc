// main global script file
///////////////////////////////////////////////////////////////////////////
/////////// TEMPLATE FOR MAKING SCUMM TYPE GAMES BY PROSKRITO  ////////////
///////////       MODIFIED FOR AGS VERSION 3 BY RULAMAN        ////////////
///////////////////////////////////////////////////////////////////////////

/*	legt den String der Datei fest, bzw. ermöglicht die "versteckte Debug-Option"
		Ist die Datei im Spieleordner vorhanden und die HIDDEN_DEBUG_ENABLED Option gesetzt,
		kann ein Spiel releast werden, ohne die Debug-Ebnabled-Option zurückzunehmen.
		So kann man später bei einem Fehler, oder seinen BETA-Testern die Datei zuschicken.
		Dann kann man auch in einem releasten Spiel noch etwaige Fehler suchen.*/
#define HIDDEN_DEBUG_STRING		"MMM_GO"
//#define HIDDEN_DEBUG_ENABLED

// automatisches Scrollen des Inventars, wenn zu wenige Items sichtbar sind
#define SCROLL_INVENTORY
#define DOORS_MAX 20
int i_Doors[DOORS_MAX];

#define TIMERS_MAX 40
int i_Timers[TIMERS_MAX];

File *debugfile;

String
GSlocname,         // on_mouse_click -> unhandled_event
GSinvloc,          // locationname>extension
SHOWNlocation;     // location translated


Character *GSPlayerUp;
Character *GSPlayerDown;
Character *BGChar;

Overlay *ovChar;

bool isBgSpeech = false;

int
GStopsaveitemRestore            = 0,
GStopsaveitemSave               = 0,
ActionLabelColorNormal          = 530,    // Used in action bar
ActionLabelColorHighlighted     = 1180,   // Used in action bar
invUparrowONsprite              = 202,    // used in repeatedly execute
invUparrowOFFsprite             = 213,    //  "   "      "         "
invDownarrowONsprite            = 204,    //  "   "      "         "
invDownarrowOFFsprite           = 214,    //  "   "      "         "
defaultfontheight               = 8,      // used in save / load guis

GSlocid,                                  // on_mouse_click ->
ItemGiven,
GScancelable,                              // MovePlayer
bgscounter=0;

eAction GSagsusedmode;                            // on_mouse_click -> unhandled_event
LocationType GSloctype;                                // on_mouse_click -> unhandled_event

int key_l_yes, key_u_yes, key_l_no, key_u_no;

// =======================================================================================

function DisplaySpeechBackgroundEx(this Character*, String message)
{
	isBgSpeech = true;
	ovChar = this.SayBackground(message);
	BGChar = this;
}

#define BGS_DELAY 6 //! this is the animation delay for ???
function repeatedly_execute_always()
{
	if ( isBgSpeech )
	{
		if ( ovChar.Valid )
		{
			if ( bgscounter >= BGS_DELAY * 2 )
				bgscounter=0;
			BGChar.LockViewFrame(BGChar.SpeechView + 1, BGChar.Loop, bgscounter/BGS_DELAY); 
			bgscounter++;
		}
		else
		{
			BGChar.UnlockView();
		}	
		isBgSpeech = false;
	}
}

// ============================= Ed expressions ===========================================

function edExpressions(facialExpression face)
{
  if (face == eNormal)
  {
    if (cEd.View == EDSAD) cEd.UnlockView();
    if (cEd.View == EDANGRYT) cEd.ChangeView(EDW);
    cEd.SpeechView = EDT;
  }
  else if (face == eSad)
  {
    cEd.LockView(EDSAD);
    cEd.SpeechView = EDSAD;
  }
  else if (face == eAngry)
  {
    if (cEd.View == EDSAD) cEd.UnlockView();
    cEd.ChangeView(EDANGRYW);
    cEd.SpeechView = EDANGRYT;
  }
  else if (face == eRed)
  {
    cEd.UnlockView();
    cEd.ChangeView(EDREDW);
    cEd.SpeechView = EDREDT;
  }
}

// ============================= math functions ===========================================

function Absolute (int value)
{
  if (value < 0) value = - value;
  return value;
}

function Offset (int point1, int point2)
{
  return Absolute (point1 - point2);
}


// ============================= action functions ===========================================
eAction global_action;
eAction default_action;
eAction alternative_action;
eAction used_action;

int action_l_keycode [eActCount];
int action_u_keycode [eActCount];
eAction button_action [9];

int action_button_normal [eActCount];
int action_button_highlight [eActCount];
Button *action_Buttonb[10];


String TranslateAction (String result, eAction action, String objekt, String item)
{
  // get translated action template
  if (action == eActWalkTo)          result = "Gehe zu %s";
  else if (action == eActLookAt)     result = "Schau an %s";
  else if (action == eActTalkTo)     result = "Rede mit %s";
  else if (action == eActGiveTo)
  {
    if (item.Length > 0)        	   result = "Gib !s an %s";
    else                             result = "Gib %s";
  }
  else if (action == eActPickUp)     result = "Nimm %s";
  else if (action == eActUse)
  {
    if (item.Length > 0)         		 result = "Benutze !s mit %s";
    else                             result = "Benutze %s";
  }
  else if (action == eActOpen)       result = "Öffne %s";
  else if (action == eActClose)      result = "Schließe %s";
  else if (action == eActPush)       result = "Drücke %s";
  else if (action == eActPull)       result = "Ziehe %s";
	else if (action == eActSwitchTo)   result = "Wechsle zu %s";

  // fill object and item into action template
  result = GetTranslation (result);
  int ip = result.Contains("!s");
  if (ip >= 0)
  {
    int op = result.Contains("%s");
    result = result.ReplaceCharAt(ip, '%');
    if (ip < op) result = result.Format(result, item, objekt);
    else         result = result.Format(result, objekt, item);
  }
  else           result = result.Format(result, objekt);
	return result;
}

function isAction (eAction test_action)
{
  return global_action == test_action;
}
/*
function UsedAction (eAction test_action)
{
  return ((used_action == test_action) && (GSagsusedmode != eModeUseinv)) || 
        ((test_action == eActUseInventory) && (used_action == eActUse) && (GSagsusedmode == eModeUseinv));
}*/

function UsedAction(eAction test_action) {
  return ((used_action == test_action) && (GSagsusedmode != eModeUseinv)) || 
         ((test_action == eActUseInventory)  && (used_action == eActUse) && (GSagsusedmode == eModeUseinv)) || 
         ((test_action == eActGiveTo)  && (used_action == eActGiveTo) && (GSagsusedmode == eModeUseinv));
}

function SetAction (eAction new_action)
{
  // set default action
  if (new_action == eActDefault)       new_action = default_action;
  // set corresponding cursormode
  if (new_action == eActWalkTo)        Mouse.Mode = eModeUsermode2;
  else if (new_action == eActLookAt)   Mouse.Mode = eModeLookat;
  else if (new_action == eActTalkTo)   Mouse.Mode = eModeTalkto;
  else if (new_action == eActGiveTo)   Mouse.Mode = eModeInteract;
  else if (new_action == eActPickUp)   Mouse.Mode = eModePickup;
  else if (new_action == eActUse)      Mouse.Mode = eModeInteract;
  else if (new_action == eActOpen)     Mouse.Mode = eModeUsermode1;
  else if (new_action == eActClose)    Mouse.Mode = eModeUsermode1;
  else if (new_action == eActPush)     Mouse.Mode = eModeUsermode1;
  else if (new_action == eActPull)     Mouse.Mode = eModeUsermode1;
  // save action
  global_action = new_action;
}

function SetDefaultAction (eAction def_action)
{
  default_action = def_action;
  SetAction (eActDefault);
}


// ============================= Load/Save game ===========================================
function GetLucasSavegameListBox(this GUI*,  ListBox *box)
{
	String strbuf,  sgdesc;
  int maxsavegames = 99;
	int counter = 0;
	strbuf = "";
	box.Clear();
	while ( counter < maxsavegames )
	{
		strbuf = String.Format("%d. ", counter + 1);

		sgdesc = Game.GetSaveSlotDescription(counter + 100);
		if ( null == sgdesc )
			sgdesc = "";
		strbuf = strbuf.Append(sgdesc);
		box.AddItem(strbuf);
		counter++;
	}
	box.TopItem = 0;
	box.SelectedIndex = -1;
}


// ============================= Timer ===========================================
function SetOwnTimer(int timerid, int timeout)
{
  if ( timerid >= TIMERS_MAX )
	{
	}
	else
	{
		i_Timers[timerid] = timeout + 1;
	}
}

function IsOwnTimerExpired(int timerid)
{
  if ( timerid >= TIMERS_MAX )
	{
	}
	else if ( i_Timers[timerid] == 1 )
  {
		i_Timers[timerid] = 0;
    return 1;
  }
  else
	{
		return 0;
	}
}

function CheckTimers()
{
  int timers = 0;
  while ( timers < TIMERS_MAX )
  {
		if ( i_Timers[timers] > 1 )
		{
			i_Timers[timers]--;
		}
		timers++;
  }
}

// ============================= GlobalCondition ===========================================
function GlobalCondition (int parameter)
{
  // here are some conditions that are used many times in the script
  int cond;
	InventoryItem* invItem;
	GUI* guiItem;
	GUIControl* guiControl;

	invItem = InventoryItem.GetAtScreenXY(mouse.x, mouse.y);
	guiItem = GUI.GetAtScreenXY(mouse.x, mouse.y);
	guiControl = GUIControl.GetAtScreenXY(mouse.x, mouse.y);

	if (parameter == 1)
  {
    // if the mouse is in the inventory and modes Walk or pickup are selected
		if ( null != invItem )
		{
			cond = ((isAction (eActWalkTo) || isAction (eActPickUp))); //( invItem.ID >= 0 ) && 
		}
  }
  else if (parameter == 2)
  {
    // if the mode is useinv and the mouse is over the active inv (like "use knife on knife")
		cond = ( null != invItem && (Mouse.Mode == eModeUseinv) && (player.ActiveInventory.ID == invItem.ID ));
  }
  else if (parameter == 3)
  {
    // if the mode is talk, or "Give", and the mouse isnt over a character
    cond = ((isAction (eActTalkTo) || (isAction (eActGiveTo) && (Mouse.Mode == eModeUseinv))) && (GetLocationType (mouse.x, mouse.y) != eLocationCharacter));
  }
  else if (parameter == 4)
  {
    // if its GIVE and the mouse isnt over a inv.item
		cond = ( ( null == invItem ) && (Mouse.Mode == eModeInteract) && isAction (eActGiveTo));
  }
  return cond;
}


// ============================= Extensions ===========================================
char Extension(this String*)
{
	if ( this.Contains(">") >= 0)
	{
		return this.Chars[this.Length - 1];
	}
	else if ( this.Contains("$") >= 0)
	{
		return this.Chars[this.Length - 1];
	}
	return 0;
}

String RemoveExtension(this String*)
{
	if ( this.Extension() ) // check Extension
	{
		return this.Truncate(this.Length - 2); // Remove Extension if any
	}
	return this; // no Extension
}

String AddExtension(this String*, char extension)
{
	String temp;
	if ( this.Extension() )
	{
		temp = this.RemoveExtension();
	}
	return String.Format("%s>%c", this,  extension);
}




// ============================= Action ===========================================
function SetAlternativeAction (String location, char extension, eAction action)
{
  if (action == eActDefault)
  {
    if (location.Extension() == extension)
    {
      alternative_action = action;
    }
  }
  else
  {
    int normalbuttonpic = action_button_normal [action];
    int overbuttonpic = action_button_highlight [action];
    // used for setting the default action given the extension.

    if (location.Extension() == extension)
    {
			if ( null != action_Buttonb[action] )
			{
				action_Buttonb[action].NormalGraphic = overbuttonpic;
			}
      // 1 = normal 2 = mouse-over 3 = button pushed
      alternative_action = action;
    }
    else if ( null != action_Buttonb[action] )
		{
			action_Buttonb[action].NormalGraphic = normalbuttonpic;
		}

		if ( null != action_Buttonb[action] )
		{
			action_Buttonb[action].MouseOverGraphic = overbuttonpic;
		}
	}
}

String OpenCloseExtensionGraphic (Object *objekt, int openGraphic, int closeGraphic, String location)
{
  if      (objekt.Graphic == closeGraphic)	return location.AddExtension('o');
  else if (objekt.Graphic == openGraphic)		return location.AddExtension('c');
}

String OpenCloseExtensionObject (Object *objekt, String location, int globalint,  int objectid)
{
		if ( object[objectid].Visible == false )
		{
			return location.AddExtension('o');
		}
		else if (object[objectid].Visible == true )
		{
			return location.AddExtension('c');
		}
}

String OpenCloseExtension (int gi, String location)
{
  if ((i_Doors[gi] == 0) || (i_Doors[gi] == 2)) return location.AddExtension('o');
  else                                          return location.AddExtension('c');
}

String VariableExtensions (String location)
{
	int		i				= 0;
	bool	b_Ready = false;
	Hotspot* hotAt = Hotspot.GetAtScreenXY(mouse.x, mouse.y);
	Object *objAt = Object.GetAtScreenXY(mouse.x, mouse.y);

	while ( i < MAX_DOORS )
	{
		if ( ((Door[i].h_Hotspot == hotAt) && (Door[i].l_Room    == player.Room)) || 
				 ((Door[i].h_NewHotspot == hotAt) && (Door[i].l_NewRoom == player.Room)) )
		{
			if ( (Door[i].i_GlobalInt == eDoorClosed) || (Door[i].i_GlobalInt == eDoorLocked) )
			{
				location = location.AddExtension('o');
			}
			else
			{
				location = location.AddExtension('c');
			}
			i = MAX_DOORS; // simulates a break;
			b_Ready = true;
		}
		i++;
	}
	// globig (Strg+F globig springt hierher)
	if ( b_Ready )
	{
	}
	else
	{
		// Syds Zimmer
				 if ((player.Room ==  1) && (hotAt.ID == 1)) location = OpenCloseExtension (3, location); // Syds Zimmertür
		// Küche
		else if ((player.Room ==  2) && (hotAt.ID == 1)) location = OpenCloseExtension (3, location); // Syds Zimmertür
		else if ((player.Room ==  2) && (hotAt.ID == 2)) location = OpenCloseExtension (4, location); // Tür zum Flur
		// Syds Flur
		else if ((player.Room ==  3) && (hotAt.ID == 1)) location = OpenCloseExtension (4, location); // Tür zur Küche
		else if ((player.Room ==  3) && (hotAt.ID == 2)) location = OpenCloseExtension (5, location); // Tür zum Bad
		else if ((player.Room ==  3) && (hotAt.ID == 3)) location = OpenCloseExtension (6, location); // Tür zum Flur
		// Syds Bad
		else if ((player.Room ==  4) && (hotAt.ID == 1)) location = OpenCloseExtension (5, location); // Tür zum Flur
	
		// Flur im ersten Stock
		else if ((player.Room ==  5) && (hotAt.ID == 1)) location = OpenCloseExtension (9, location); // Tür zu Achmeds Wohnzimmer
		// Flur im zweiten Stock
		else if ((player.Room ==  6) && (hotAt.ID == 2)) location = OpenCloseExtension (6, location); // Tür zu Syds Wohnzimmer
		// Strasse
		else if ((player.Room ==  7) && (hotAt.ID == 1)) location = OpenCloseExtension (7, location); // 
		// S-Mart
		else if ((player.Room ==  8) && (hotAt.ID == 1)) location = OpenCloseExtension (7, location); // 

		// Achmeds Zimmer
		else if ((player.Room == 18) && (hotAt.ID == 1)) location = OpenCloseExtension (8, location); // Tür zu Achmeds Küche
		// Achmeds Küche
		else if ((player.Room == 19) && (hotAt.ID == 1)) location = OpenCloseExtension (8, location); // Tür zu Achmeds Zimmer
		// Achmeds Wohnzimmer
		else if ((player.Room == 20) && (hotAt.ID == 3)) location = OpenCloseExtension (9, location); // Tür zum Flur erster Stock
		else if ((player.Room == 20) && (hotAt.ID == 2)) location = OpenCloseExtension (10, location); // Tür zum Bad
		// Achmeds Bad
		else if ((player.Room == 21) && (hotAt.ID == 1)) location = OpenCloseExtension (10, location); // Tür zum Wohnzimmer

		// vor Woodys Shack
		else if ((player.Room == 13) && (hotAt.ID == 1)) location = OpenCloseExtension (11, location); // Tür zum Woodys Shack
		// Shack innen
		else if ((player.Room == 24) && (hotAt.ID == 16)) location = OpenCloseExtension (11, location); // Tür zur Straße
	}
	return location;
}

function CheckDefaultAction()
{
  // you could want to change which extension activates which default action, or which button sprite
  // it changes. The extensions are characters, so remember to put them with single ', not ".
	String location;
	location = Game.GetLocationName(mouse.x, mouse.y);
	InventoryItem *invItem = InventoryItem.GetAtScreenXY(mouse.x, mouse.y);

  if (location.Extension() == 0)
  {
    // Setting default modes if the thing has no extension:
    if ( GetLocationType(mouse.x, mouse.y) == eLocationCharacter )
    {
      // if it is a character
      location = location.AddExtension ('t'); // set default action "talk to"
    }
		else if( (GetLocationType(mouse.x, mouse.y) != eLocationNothing) || null != invItem )
    {
      // if its an inv item, a hotspot or an object
      location = location.AddExtension('l'); // set default action "look at"
		}
	  else
    {
      location = location.AddExtension('n'); // set default action "none"
    }
  }
  else if (location.Extension() == 'v')
  {
    // if the default action depends on some events
    location = location.RemoveExtension();
    location = VariableExtensions (location);
	}


  if (GlobalCondition (2) || GlobalCondition (3) || GlobalCondition (4))
  {
    location = ">n"; //Dont send the name of the hotspt/obj/char/inv to the action bar and set default action "none"
  }
  GSinvloc = String.Format("%s", location);
  if ((location.Extension() == 'u') && ( null != invItem ) )
  {
    // it's an inv item
    location = location.RemoveExtension();
    location = location.AddExtension('l'); // set default action "look at"
	}
  SetAlternativeAction (location, 'n', eActDefault);
  SetAlternativeAction (location, 'g', eActGiveTo);
  SetAlternativeAction (location, 'p', eActPickUp);
  SetAlternativeAction (location, 'u', eActUse);
  SetAlternativeAction (location, 'o', eActOpen);
  SetAlternativeAction (location, 'l', eActLookAt);
  SetAlternativeAction (location, 's', eActPush);
  SetAlternativeAction (location, 'c', eActClose);
  SetAlternativeAction (location, 't', eActTalkTo);
  SetAlternativeAction (location, 'y', eActPull);
  location = location.RemoveExtension();
  SHOWNlocation = location;
}
// ============================= ActionBar ===========================================

function UpdateActionBar()
{
  // set the text in the action bar
  String madetext;
  int action = global_action;
  String objekt;
  String item;
	GUIControl *guic;
	madetext = "";
  objekt = SHOWNlocation;
  item = "";
  
  if (Mouse.Mode == 4)
  {
    // use or give inventory item
    item = player.ActiveInventory.Name;
		item = item.RemoveExtension();
  }
  else if (GlobalCondition (1) == 1)
  {
    // if the mouse is in the inventory and modes Walk or pickup are selected
    action = eActUse;
	}
	madetext = TranslateAction (madetext, action, objekt, item);
  // show action text
	gAktionText.Text = madetext;
	gAktionText.TextColor = ActionLabelColorNormal;
}

// ============================= Inventory ===========================================
function GiveInvEx (int invitem, Character *charidfrom, Character *charidto)
{
  //for passing inv items between characters
  int amount;
	amount = charidfrom.InventoryQuantity[invitem];
  charidfrom.InventoryQuantity[invitem] = 0;
  charidto.InventoryQuantity[invitem] = amount;
  UpdateInventory ();
}


bool GiveInv(this Character*, InventoryItem *invItem, Character *charac)
{
	return GiveInvEx(invItem.ID, player, charac);
}

bool ReceiveInv(this Character*, InventoryItem *invItem, Character *charac)
{
	return GiveInvEx(invItem.ID, charac, player);
}

function GiveInv (int invitem, Character *charid)
{
  //for giving an inv item to other player
  GiveInvEx (invitem, player, charid);
}


// ============================= translation ===========================================
String ClearToSpace(String text)
{
	int p = 0;
	// ignore white spaces at the beginning
	while ( ( p < text.Length ) && ( text.Chars[p] == ' ' ) )
	{
		p++;
	}
  // write white spaces until next white space
	while ( ( p < text.Length ) && ( text.Chars[p] != ' ' ) )
	{
		text = text.ReplaceCharAt(p, ' ');
		p++;
	}
	return text;
}


function TranslateNumber (String number_name)
{
  String tr;
  tr = ClearToSpace(GetTranslation (number_name));
  return tr.AsInt;
}

function SetActionButtons (eAction action, String button_definition)
{
	// extract data from button_definition
	String translat;
	int i;

	if (IsTranslationAvailable())
	{
		translat = GetTranslation(button_definition);
		translat = ClearToSpace (translat);
	}
	else
	{
		translat = button_definition;
		translat = ClearToSpace (translat);
	}

	i = translat.AsInt;
	translat = ClearToSpace(translat);
			 if ( i == 4 ) { action_Buttonb[action] = gMainLookat; } //Schliesse	4
	else if ( i == 2 ) { action_Buttonb[action] = gMainUse;    } //Nimm				2
	else if ( i == 1 ) { action_Buttonb[action] = gMainPickup; } //Benutze		1
	else if ( i == 3 ) { action_Buttonb[action] = gMainOpen;   } //Öffne			3
	else if ( i == 6 ) { action_Buttonb[action] = gMainClose;  } //Ziehe			6
	else if ( i == 0 ) { action_Buttonb[action] = gMainGive;   } //Schau			0
	else if ( i == 8 ) { action_Buttonb[action] = gMainPull;   } //Rede				8
	else if ( i == 5 ) { action_Buttonb[action] = gMainPush;   } //Gib				5
	else if ( i == 7 ) { action_Buttonb[action] = gMainTalkto; } //Drücke			7


  action_button_normal [action] = translat.AsInt;
		translat = ClearToSpace(translat);
  action_button_highlight [action] = translat.AsInt;
		translat = ClearToSpace(translat);

  int p = translat.Length - 1;
  while (p > 0)
  {
    action_l_keycode [action] = translat.Chars[p];
    p--;
    action_u_keycode [action] = translat.Chars[p];
    if (action_l_keycode [action] != ' ')
    {
      p = 0;
    }
  }
  if ( null != action_Buttonb[action] )
		button_action [action_Buttonb[action].ID] = action;
}

function AdjustLanguage ()
{
  // --- translate yes/no-keys ---
  String yes_no;
  yes_no = GetTranslation ("JjNn");
  key_u_yes = yes_no.Chars[0];
  key_l_yes = yes_no.Chars[1];
  key_u_no  = yes_no.Chars[2];
  key_l_no  = yes_no.Chars[3];
  // --- translate GUI action buttons ---
  SetActionButtons (eActGiveTo,  "a_button_give 5 802 803 Dd");
  SetActionButtons (eActPickUp,  "a_button_pick_up 2 800 801 Ee");
  SetActionButtons (eActUse,     "a_button_use 1 794 795 Ww");
  SetActionButtons (eActOpen,    "a_button_open 3 790 791 Aa");
  SetActionButtons (eActLookAt,  "a_button_look_at 0 788 789 Qq");
  SetActionButtons (eActPush,    "a_button_push 7 798 799 Xx");
  SetActionButtons (eActClose,   "a_button_close 4 796 797 Ss");
  SetActionButtons (eActTalkTo,  "a_button_talk_to 8 804 805 Cc");
  SetActionButtons (eActPull,    "a_button_pull 6 792 793 Yy");
  // --- load font corresponding to language and screen width ---
  String font_info;
  if (system.ViewportWidth == 320)      font_info = GetTranslation ("font_320: 1  0  0  0  0  0  0  0  0  0  0  0  0  0  0");
  else if (system.ViewportWidth == 640) font_info = GetTranslation ("font_640: 13 14 14 14 14 14 14 14 14 14 14 14 14 14 14");
  font_info = ClearToSpace(font_info);

	// Labeles (Strg+F Labeles springt hierher)
  Game.SpeechFont     = font_info.AsInt; font_info = ClearToSpace(font_info);        // Speech
	gAktionText.Font    = font_info.AsInt; font_info = ClearToSpace(font_info);     // Status-Line
  gOptionsTitel.Font  = font_info.AsInt; font_info = ClearToSpace(font_info);   // Save/Load-GUI Label
  // Fehler im Speichern-Dialog korrigiert nichts auskommentieren
  gOptionsSave.Font   = font_info.AsInt; font_info = ClearToSpace(font_info);   // Save-Button of Save/Load-GUI
  gOptionsLoad.Font   = font_info.AsInt; font_info = ClearToSpace(font_info);   // Load-Button of Save/Load-GUI
  gOptionsPlay.Font   = font_info.AsInt; font_info = ClearToSpace(font_info);   // Play-Button of Save/Load-GUI
  gOptionsExit.Font   = font_info.AsInt; font_info = ClearToSpace(font_info);   // Quit-Button of Save/Load-GUI
  gPausedText.Font    = font_info.AsInt; font_info = ClearToSpace(font_info);   // Pause-GUI Label

  gRestoreTitel.Font  = font_info.AsInt; font_info = ClearToSpace(font_info);   // Restore-GUI Label
  gRestoreCancel.Font = font_info.AsInt; font_info = ClearToSpace(font_info);   // Cancel-Button of Load-GUI
  gSaveTitel.Font     = font_info.AsInt; font_info = ClearToSpace(font_info);   // Save-GUI Label
  gSaveOK.Font        = font_info.AsInt; font_info = ClearToSpace(font_info);   // OK-Button of Save-GUI
  gSaveCancel.Font    = font_info.AsInt; font_info = ClearToSpace(font_info);   // Cancel-Button of Save-GUI

  gConfirmQuestion.Font = font_info.AsInt; font_info = ClearToSpace(font_info);   // Quit-GUI Label
  gRestartQuestion.Font = font_info.AsInt; font_info = ClearToSpace(font_info);  // Restart-GUI Label
}

// ============================= MovePlayer ===========================================
function MovePlayerEx (int x, int y, int direct)
{
  // Move the player character to x,y coords, waiting until he/she gets there,
  // but allowing to cancel the action by pressing a mouse button.

	GUI *guiAt = GUI.GetAtScreenXY(mouse.x, mouse.y);
	InventoryItem *invAt = InventoryItem.GetAtScreenXY(mouse.x, mouse.y);

	if ( g_PlayerCanMove > 0 )
  {
    int cursorspritenumber = 16,
    blankcursorspritenumber = 26;
		GScancelable = 0;

		Mouse.ChangeModeGraphic(eModeWait, cursorspritenumber);

		if (direct == 0)
			player.Walk(x, y);
		
    else
			player.Walk(x, y, eNoBlock, eAnywhere);

		// wait for release of mouse button
    while (player.Moving && (Mouse.IsButtonDown(eMouseLeft) || Mouse.IsButtonDown(eMouseRight) ))
    {
      Wait (1);
      Mouse.Update();
      CheckDefaultAction ();
    }
    // abort moving on new mouse down
		
    while (player.Moving)
    {
      if ( Mouse.IsButtonDown (eMouseLeft) && ( null == guiAt || null != invAt ))
      {
        player.StopMoving();
        GScancelable = 1;
      }
      else if ( Mouse.IsButtonDown(eMouseRight) && (null == guiAt || null != invAt ))
      {
        player.StopMoving();
        GScancelable = 2;
			}
      else
      {
        Wait (1);
        Mouse.Update();
        CheckDefaultAction();
      }
    }
    mouse.ChangeModeGraphic(eModeWait, blankcursorspritenumber);

		if ( GScancelable == 0 && player.x == x && player.y == y )
		{
			return 2;
		}
    else if ( GScancelable == 0 )
		{
			return 1;
		}
    else
		{
			return 0;
		}
  }
  else return 0;
}

//! veraltet (obsolete)
function MovePlayer (int x, int y)
{
  //Move the player character to x,y coords, waiting until he/she gets there, but allowing to cancel the action
  //by pressing a mouse button.
  return MovePlayerEx (x, y, 0);
}


// ============================= Go ===========================================
// this section after MovePlayer

function GoToCharacterEx (Character *charidwhogoes, Character *charid, int direction, int xoffset, int yoffset, int NPCfacesplayer, int blocking)
{
  //Goes to a character staying at the side defined by 'direction': 1 up, 2 right, 3 down, 4 left
  //and it stays at xoffset or yofsset from the character. NPCfacesplayer self-explained. ;)
  // blocking: 0=non-blocking; 1=blocking; 2=semi-blocking
  int playerchar, charidx, charidy, playerx, playery;
  charidx = charid.x;
  charidy = charid.y;
  playerx = player.x;
  playery = player.y;
  int arrived = 1;
  if ((Offset (playerx, charidx) > xoffset) || (Offset (playery, charidy) > yoffset))
  {
    if (direction == 0)
    {
      // el camino mas cercano
      if (Offset (charidx, playerx) >= Offset (charidy, playery))
      {
        // dcha o izda
        if (playerx >= charidx) direction = 2; //right
        else direction = 4; //left
      }
      else
      {
        if (playery >= charidy) direction = 3; //abajo
        else direction = 1;
      }
    }
    // calculate target position
         if ( direction == eDirUp    ) charidy -= yoffset;
    else if ( direction == eDirLeft  ) charidx += xoffset;
    else if ( direction == eDirDown  ) charidy += yoffset;
    else if ( direction == eDirRight ) charidx -= xoffset;
    // move character
    if (blocking == 0)
    {
      player.Walk(charidx, charidy);
      arrived = 0;
    }
    else if (blocking == 1)
    {
      charidwhogoes.Walk(charidx, charidy, eBlock);
      arrived = 1;
    }
    else if (blocking == 2) arrived = MovePlayer (charidx, charidy);
  }
  if (arrived > 0)
  {
    // characters only face each other after the moving character arrived at the target point
    if (NPCfacesplayer == 1)  charid.FaceCharacter(charidwhogoes);
    charidwhogoes.FaceCharacter(charid);
  }
  return arrived;
}

function NPCGoToCharacter (Character *charidwhogoes, Character *charidtogoto, int direction, int NPCfacesplayer, int blocking){
  // same as above but with default x and y offset.
  int defaultxoffset, defaultyoffset;
  defaultxoffset = 35;
  defaultyoffset = 20;
  return GoToCharacterEx (charidwhogoes, charidtogoto, direction, defaultxoffset, defaultyoffset, NPCfacesplayer, blocking);
}

function GoToCharacter (Character *charid, int direction, int NPCfacesplayer, int blocking){
  // same as above but with default x and y offset.
  int defaultxoffset, defaultyoffset;
  defaultxoffset = 35;
  defaultyoffset = 20;
  return GoToCharacterEx (player, charid, direction, defaultxoffset, defaultyoffset, NPCfacesplayer, blocking);
}

function GoTo (int blocking)
{
  // Goes to whatever the player clicked on.
  // blocking: 0=non-blocking; 1=blocking; 2=semi-blocking
	Hotspot *hotAt = Hotspot.GetAtScreenXY(mouse.x, mouse.y);
	Character *charAt = Character.GetAtScreenXY(mouse.x, mouse.y);
	Object *objAt = Object.GetAtScreenXY(mouse.x, mouse.y);
  int xtogo, ytogo;
  int locationtype = GetLocationType (mouse.x, mouse.y);
  int arrived = 0;
  if (locationtype == 2) arrived = GoToCharacter (charAt, 0, 0, blocking);
  else
  {
		if ( hotAt )
			if (locationtype == 1 && hotAt.ID > 0)
			{
				xtogo = hotAt.WalkToX;
				ytogo = hotAt.WalkToY;
			}
		
    if (locationtype == 3)
    {
      int objekt = objAt.ID;
      xtogo = objAt.X;
      ytogo = objAt.Y;
		}
		if ( hotAt )
			if (hotAt.ID == 0)
			{
				xtogo = mouse.x;
				ytogo = mouse.y;
			}
			else
			{
				xtogo = mouse.x;
				ytogo = mouse.y;
			}
		
    xtogo += GetViewportX ();
    ytogo += GetViewportY ();
		
    if (blocking == 0) player.Walk(xtogo, ytogo);
    else if (blocking == 1)
    {
      player.Walk(xtogo, ytogo, eBlock);
      arrived = 1;
    }
    else if (blocking == 2) arrived = MovePlayer (xtogo, ytogo);
  }
  return arrived;
}

function Go ()
{
  // Go to whatever the player clicked on. You can cancel the action, and returns 1 if the player has gone to it.
  return GoTo (2);
}

// ============================= interaction functions ===========================================

// this section after MovePlayer
function PlaceCharacter (this Character*, int x, int y, eDirection dir)
{
  this.x = x;
  this.y = y;
  this.FaceDirection(dir);
}

//! veraltet (obsolete)
function PlacePC (int x, int y, eDirection dir)
{
  player.PlaceCharacter(x, y, dir);
}

function any_click_move (int x, int y, eDirection dir)
{
  int result = MovePlayer (x, y);
  if (result)
  {
   player.FaceDirection(dir);
    Wait (5);
  }
  return result;
}

function any_click_walk (int x, int y, eDirection dir){
  int result = 1;
  if (UsedAction (eActWalkTo)) any_click_move (x, y, dir);
  else result = 0;
  return result;
  // 0 = unhandled
  // 1 = handled
}

function any_click_walk_look (int x, int y, eDirection dir, String lookat){
  int result = any_click_walk (x, y, dir);
  if ((result == 0) && (UsedAction (eActLookAt) && (lookat.Length > 0)))
  {
    result = 1;
    if (any_click_move (x, y, dir)) player.Say(lookat);
  }
  return result;
  // 0 = unhandled
  // 1 = handled
}

function init_object(this Object*,  int gi)
{
	if ( null != this )
	{
		this.Clickable = false;	// die Türenobjekte nicht Klickbar machen
		if (i_Doors[gi] == 1) this.Visible = true;
		else                  this.Visible = false;
	}
}


String door_lookat;
String door_islocked;
String door_wrongitem;

function SetDoorStrings (String lookat, String islocked, String wrongitem)
{
  door_lookat = lookat;
  door_islocked = islocked;
  door_wrongitem = wrongitem;
}

function any_click_on_door_special (int gi, Object *objekt, int x, int y, eDirection dir, int nr_room,
		int nr_x, int nr_y, eDirection nr_dir, int opensound, int closesound, int key, int closevalue)
{
  // key = -1: opens also locked doors without key
  // key = -2: door can't be unlocked (like rusted)
	InventoryItem *charInv = player.ActiveInventory;
	
  int result = 1;
	if (UsedAction(eActPickUp))
	{
		player.FaceDirection(dir);
		player.Say("Ach nö, will heute keine Türen schleppen.");
	}
	else if (UsedAction(eActPull) || UsedAction(eActPush))
	{
		player.FaceDirection(dir);
		player.Say("Man kann auch eine Tür \"öffnen\" oder \"schließen\".");
	}
  else if (UsedAction (eActClose))
  {
    if (i_Doors[gi] == 0)
    {
      player.Say("Das ist doch zu.");
    }
    else if (i_Doors[gi] == 1)
    {
      if (any_click_move (x, y, dir))
      {
        PlaySound (closesound);
        objekt.Visible = false;
        i_Doors[gi] = closevalue;
      }
    }
  }
  else if (UsedAction (eActOpen))
  {
    if ( (i_Doors[gi] == 0) || ((i_Doors[gi] == 2) && (key == -1)) )
    {
      if (any_click_move (x, y, dir))
      {
        PlaySound (opensound);
        objekt.Visible = true;
        i_Doors[gi] = 1;
      }
    }
    else if (i_Doors[gi] == 1)
    {
      player.Say("Das ist schon offen.");
    }
    else if (i_Doors[gi] == 2)
    {
      if (any_click_move (x, y, dir))
      {
       player.Say(door_islocked);
      }
    }
  }
  else if (UsedAction (eActWalkTo))
  {
    if ( any_click_move (x, y, dir) == 2 ) // == 2, korrektur Door-Script, falls sich Charakter nicht bewegen kann
    {
      if (i_Doors[gi] == 1)
      {
        player.EnterRoom (nr_room, nr_x, nr_y, nr_dir);
        result = 2;
      }
    }
  }
  else if (UsedAction (eActLookAt) && (door_lookat.Length > 0))
  {
    if (any_click_move (x, y, dir)) player.Say(door_lookat);
  }
  else if (UsedAction (eActUseInventory) && (key >= 0))
  {
    if (any_click_move (x, y, dir))
    {
			if ( charInv )
			{
				if (charInv.ID == key)
				{
					if (i_Doors[gi] == 2)
					{
						PlaySound (2);
						objekt.Visible = true;
						i_Doors[gi] = 1;
					}
				}
				else player.Say(door_wrongitem);
			}
    }
  }
  else result = 0;
  return result;
  // 0 = unhandled
  // 1 = handled
  // 2 = NewRoom
}

function any_click_on_door (int GI, Object *objekt, int x, int y, eDirection dir, int nr_room, int nr_x, int nr_y, eDirection nr_dir) {
  SetDoorStrings ("", "", "");
  return any_click_on_door_special (GI, objekt, x, y, dir, nr_room, nr_x, nr_y, nr_dir, 2, 3, -1, 0);
}

function any_click_use_inv (int item, int x, int y, eDirection dir) {
  int result = 0;
	InventoryItem *charInv = player.ActiveInventory;
  if (UsedAction (eActUseInventory))
  {
		if ( charInv )
		{
			if ( charInv.ID == item )
			{
				if ( any_click_move (x, y, dir) ) result = 2;
				else                              result = 1;
			}
		}
  }
  return result;
  // 0 = unhandled
  // 1 = handled, but canceled
  // 2 = use this item
}

function any_click_walk_look_pick (int x, int y, eDirection dir, string lookat, Object *objekt, InventoryItem *item, int gi, int sound)
{
  int result = any_click_walk_look (x, y, dir, lookat);
  if ((result == 0) && UsedAction (eActPickUp))
  {
    if (any_click_move (x, y, dir))
    {
      if (sound >= 0) PlaySound (sound);
      if (objekt.ID >= 0) objekt.Visible = false;
      if (item.ID >= 0) player.AddInventory(item);
      if (gi >= 0) i_Doors[gi] = 0;
      result = 2;
    }
  }
  return result;
  // 0 = unhandled
  // 1 = handled, but canceled
  // 2 = picked up
}

/**********************************************************************/
/*															Functions															*/
/**********************************************************************/
int DoorType::SetStrings(String lookat, String islocked, String wrongitemopen,  String wrongitemclose, String lookAt2)
{
	this.s_LookAt					= lookat;
	this.s_NewLookAt			= lookAt2;
	this.s_IsLocked				= islocked;
	this.s_WrongItemOpen	= wrongitemopen;
	this.s_WrongItemClose	= wrongitemclose;
}

/**********************************************************************
***********************************************************************/
int DoorType::ClickSpecial(int opensound, int closesound, InventoryItem *iItem, int closevalue)
{
  // key = -1: opens also locked doors without key
  // key = -2: door can't be unlocked (like rusted)
	InventoryItem *charInv = player.ActiveInventory;
  int result = 1;
	int key;
	
	if ( iItem == null )
	{
		key = -1;
	}
	else
	{
		key = iItem.ID;
	}
	
	int					i_XPosition;
	int					i_YPosition;
	int					i_NewXPosition;
	int					i_NewYPosition;
	eDirection	l_Direction;
	eDirection	l_NewDirection;
	int					l_NewRoom;
	String			s_LookAt;
	Object			*o_Objekt;

	if ( player.Room == this.l_Room )
	{
		i_XPosition			= this.i_XPosition;
		i_YPosition			= this.i_YPosition;
		i_NewXPosition	= this.i_NewXPosition;
		i_NewYPosition	= this.i_NewYPosition;
		l_Direction			= this.l_Direction;
		l_NewDirection	= this.l_NewDirection;
		l_NewRoom				= this.l_NewRoom;
		s_LookAt				= this.s_LookAt;
		o_Objekt				= this.o_Objekt;

		if ( s_LookAt == null )
		{
			s_LookAt = s_LookAtStandard;
		}
	}
	else if ( player.Room == this.l_NewRoom )
	{
		i_XPosition			= this.i_NewXPosition;
		i_YPosition			= this.i_NewYPosition;
		i_NewXPosition	= this.i_XPosition;
		i_NewYPosition	= this.i_YPosition;
		l_Direction			= this.l_NewDirection;
		l_NewDirection	= this.l_Direction;
		l_NewRoom				= this.l_Room;
		s_LookAt				= this.s_NewLookAt;
		o_Objekt				= this.o_NewObjekt;

		if ( s_LookAt == null )
		{
			s_LookAt = s_NewLookAtStandard;
		}
	
		l_Direction 		= (l_Direction+2)%4;
		l_NewDirection 	= (l_NewDirection+2)%4;		
	}
	else
	{
		result = 1;
	}

  if ( UsedAction (eActClose) )
  {
    if ( this.i_GlobalInt == eDoorClosed )
    {
      player.Say("Das ist schon zu.");
    }
    else if ( this.i_GlobalInt == eDoorOpen )
    {
      if ( any_click_move(i_XPosition, i_YPosition, l_Direction) )
      {
        PlaySound(closesound);
        o_Objekt.Visible = false;
        this.i_GlobalInt = closevalue;
      }
    }
  }
  else if ( UsedAction(eActOpen) )
  {
    if ( (this.i_GlobalInt == eDoorClosed) || ((this.i_GlobalInt == eDoorLocked) && (key == -1)) )
    {
      if ( any_click_move(i_XPosition, i_YPosition, l_Direction) )
      {
        PlaySound(opensound);
        o_Objekt.Visible = true;
        this.i_GlobalInt = eDoorOpen;
      }
    }
    else if ( this.i_GlobalInt == eDoorOpen )
    {
      player.Say("Das ist schon offen.");
    }
    else if ( this.i_GlobalInt == eDoorLocked )
    {
      if ( any_click_move(i_XPosition, i_YPosition, l_Direction) )
      {
				if ( this.s_IsLocked != null )
				{
					player.Say(this.s_IsLocked);
				}
				else
				{
					player.Say(s_IsLockedStandard);
				}
      }
    }
  }
  else if ( UsedAction (eActWalkTo) )
  {
    if ( any_click_move(i_XPosition, i_YPosition, l_Direction) == 2 ) // == 2, korrektur Door-Script, falls sich Charakter nicht bewegen kann
    {
      if ( this.i_GlobalInt == eDoorOpen )
      {
        player.EnterRoom(l_NewRoom, i_NewXPosition, i_NewYPosition, l_NewDirection);
        result = 2;
      }
    }
  }
  else if ( UsedAction(eActLookAt) && (s_LookAt.Length > 0) )
  {
    if ( any_click_move(i_XPosition, i_YPosition, l_Direction) )
		{
			player.Say(s_LookAt);
		}
  }
  else if ( UsedAction(eActUseInventory) && (key >= 0) )
  {
    if (any_click_move(i_XPosition, i_YPosition, l_Direction) )
    {
      if ( charInv )
      {
        if ( charInv.ID == key )
        {
          if ( this.i_GlobalInt == 2 )
          {
            PlaySound(2);
            if ( o_Objekt )
            {
              o_Objekt.Visible = true;
            }
            this.i_GlobalInt = 1;
          }
        }
        else
        {
          if ( o_Objekt.Visible )
          {
            if ( this.s_WrongItemClose != null ) 
            {
              player.Say(this.s_WrongItemClose);
            }
            else
            {
              player.Say(s_WrongItemCloseStandard);
            }
          }
          else
          {
            if ( this.s_WrongItemOpen != null ) 
            {
              player.Say(this.s_WrongItemOpen);
            }
            else
            {
              player.Say(s_WrongItemOpenStandard);
            }
          }
        }
      }
    }
  }
  else result = 0;
  return result;
  // 0 = unhandled
  // 1 = handled
  // 2 = NewRoom
}

/**********************************************************************
***********************************************************************/
int DoorType::Click()
{
	return this.ClickSpecial(2, 3, null, 0);
}

/**********************************************************************
***********************************************************************/
int DoorType::Init(Object *o_Objekt, Hotspot *h_Hotspot)
{
	if ( null != o_Objekt )
	{
		o_Objekt.Clickable = false;	// die Türenobjekte nicht Klickbar machen
		if ( this.i_GlobalInt == eDoorOpen ) o_Objekt.Visible = true;
		else                       				   o_Objekt.Visible = false;
		
		if ( this.l_Room == player.Room )
		{
			this.o_Objekt			= o_Objekt;
		}
		else if ( this.l_NewRoom == player.Room )
		{
			this.o_NewObjekt	= o_Objekt;
		}
	}
	if ( null != h_Hotspot )
	{
		if ( this.l_Room == player.Room )
		{
			this.h_Hotspot		= h_Hotspot;
		}
		else if ( this.l_NewRoom == player.Room )
		{
			this.h_NewHotspot	= h_Hotspot;
		}
	}
}


int walk_to_x, walk_to_y;
eDirection walk_to_dir;

function SetWalkTo(int x, int y, eDirection dir)
{
  walk_to_x = x;
  walk_to_y = y;
  walk_to_dir = dir;
}

function MovedTo()
{
  return any_click_move (walk_to_x, walk_to_y, walk_to_dir);
} 

function WalkedToLookedAt(string lookat)
{
  return any_click_walk_look (walk_to_x, walk_to_y, walk_to_dir, lookat);
}

function UsedInvItem(int item)
{
  return any_click_use_inv (item, walk_to_x, walk_to_y, walk_to_dir);
}

function WalkedToLookedAtPickedUp(string lookat, Object *objekt, InventoryItem *item, int GI, int sound)
{
  return any_click_walk_look_pick (walk_to_x, walk_to_y, walk_to_dir, lookat, objekt, item, GI, sound);
}


///////////////////////////////////////
// Background queued talking v1.02
///////////////////////////////////////


#define BUFFER_SIZE 300
#define AGS_STRING_LENGTH 200

struct MESSAGESTRING
{
   Character *CharID;
   int  anim_disabled;
	 String byte;
};

MESSAGESTRING Buffer[BUFFER_SIZE];

function mod(int a, int b) { return a - (b*(a/b)); }

function BufferSetString(int sID, String text)
{
   if (sID<0 || sID>=BUFFER_SIZE) { Display("error: SetString buffer error!"); QuitGame(0); }
   Buffer[sID].byte = text;
   return text.Length;
}

String BufferGetString(int sID)
{
   if (sID<0 || sID>=BUFFER_SIZE) { Display("error: GetString buffer error!"); QuitGame(0); }
   return Buffer[sID].byte;
}


int cur_str=0;
int cur_say=0;
int stop_talk   =  0;
int cur_channel = -1;

Overlay *currentOverlay;
Character *prev_char;

function qDisplaySpeech(Character *CharID, String message)
{
   int i = mod(cur_str, BUFFER_SIZE);

   BufferSetString(i, message);
   Buffer[i].CharID = CharID;
   cur_str++;
   if (cur_str >= BUFFER_SIZE) cur_str = 0;
}

function qIsTalking()
{
	if ( null != currentOverlay )
		return currentOverlay.Valid;
}

function GetSoundNumber(String text) //return 0 if unsuccessful
{
   int pos = text.Contains("@");
   if ( pos < 0 ) return 0;
   int i = pos + 1;
   String str_rez = "";
   int Charr = text.Chars[i];
   while ( Charr >= '0' && Charr <= '9' && i < text.Length )
	 {
      str_rez = String.Format("%s%c", str_rez, Charr);
      i++;
      Charr = text.Chars[i];
   }

   while ( i <= text.Length )
	 {
      text = text.ReplaceCharAt(pos, text.Chars[i]);
      i++;
      pos++;
   }
   return str_rez.AsInt;
}

function GetFreeChannel() // returns a channel number
{
   if      ( IsChannelPlaying(5) == 0 ) return 5;
   else if ( IsChannelPlaying(4) == 0 ) return 4;
   else return 3;
}

function qStopSpeechChannel()
{
   if ( cur_channel > 2 )
      if ( IsChannelPlaying(cur_channel) )
			{
         StopChannel(cur_channel);
         cur_channel = -1;
      }
}

function qStopSpeech()
{
   if (qIsTalking())
	 {
      qStopSpeechChannel();
      currentOverlay.Remove();

			int i = mod(cur_say, BUFFER_SIZE);
      Character *CharID = Buffer[i].CharID;
			if ( null != CharID )
					CharID.UnlockView();

			if ( null != prev_char )
			{
				prev_char.UnlockView();
				prev_char = null;
			}
      stop_talk = 0;
      cur_say = cur_str;
   }
}

function DisplaySpeechQ_RE()
{

   if (qIsTalking()==0) // wait for character to finish talking
	 {
      if (cur_say < cur_str) // if something left to be said
			{
         int i = mod(cur_say, BUFFER_SIZE);
         Character *CharID = Buffer[i].CharID;

         String buf;
         buf = BufferGetString(i);

         qStopSpeechChannel();
         int cur_sound = GetSoundNumber(buf);
         cur_channel   = GetFreeChannel();
         if ( cur_sound > 0 ) PlaySoundEx(cur_sound, cur_channel);

         currentOverlay = CharID.SayBackground(buf);
         stop_talk = 1;

         if ( null != prev_char )
						prev_char.UnlockView();
         prev_char = CharID;

         if ( CharID.Animating == 0 && Buffer[ i ].anim_disabled == 0 )
				 {
            int view = CharID.SpeechView + 1;
            if (view < 1) { Display("error: Talk view isn't assigned!"); QuitGame(0); }
            int loop = CharID.Loop;
            int delay = CharID.AnimationSpeed;
            CharID.LockView(view);
						CharID.Animate(loop, delay, eRepeat, eNoBlock, eForwards);
         }

         Buffer[i].anim_disabled = 0;
         cur_say++;
         if (cur_say >= BUFFER_SIZE) cur_say = 0;
			}
			else if (stop_talk)
			{ //finish talk animation
         if ( null != prev_char )
				 {
					 prev_char.UnlockView();
					 prev_char = null;
					}
         qStopSpeechChannel();
         stop_talk = 0;
      }
   } // end of if (qIsTalking()==0)
}

String str_delay;

String Delay(int time)
{
	int n = time;
	if ( n < 1 )
		n = 1;
	else if ( n >= AGS_STRING_LENGTH )
		n = AGS_STRING_LENGTH - 1;

	String format;
	format  = String.Format("%%%dc", n);
	str_delay = String.Format(format, ' ');
	Buffer[mod(cur_str, BUFFER_SIZE)].anim_disabled = 1;
	return str_delay;
}

function qSkipCurrentMessage()
{
   if ( qIsTalking() )
		currentOverlay.Remove();
}


// ============================= game_start ===========================================
function game_start ()
{
	int i = 0;

	//Game.SetSaveGameDirectory(".");
  
	// called when the game starts, before the first room is loaded
  // --- translate GUI action buttons ---
  AdjustLanguage();
	ovChar = null;

	// g_PlayerCanMove = 1; // ist im 'Global variables' Dialog bereits vorbelegt
	// (0=steht; 1=kann sich bewegen)

	while ( i < DOORS_MAX )
	{
		i_Doors[i] = 0;
		i++;
	}

	InvWindow *invWin;
  // --- initialize game settings ---
  game.dialog_options_y = 1;
  game.dialog_options_x = 1;

	if ( invWin )
	{
		invWin.ItemHeight = 40;
		invWin.ItemWidth = 24;
	}

  game.text_speed = 10;
  SetDefaultAction (eActWalkTo);
  gMaps.Visible = false;
	// Für Debug-Aktionen ohne daß die Option 'Enable Debug-Mode' weggenommen wird
	//debugfile = File.Open(HIDDEN_DEBUG_STRING,  eFileRead); // steht nur zur Verfügung, wenn die Datei MMM_GO vorhanden ist
	
	DoorSetup();
  
  SetGameNameTranslated(1); // Game Name translated in the title bar (only for other languages)
}

// ============================= on_mouse_click ===========================================
// this section after GoToCharacter

function on_mouse_click (int button)
{
  // called when a mouse button is clicked. button is either LEFT or RIGHT
  int mrx = mouse.x + GetViewportX ();
  int mry = mouse.y + GetViewportY ();
	
	Object *objAt;
	Hotspot *hotAt;
	Character *charAt;
	InventoryItem *invAt;
	objAt = Object.GetAtScreenXY(mouse.x, mouse.y);
	hotAt = Hotspot.GetAtScreenXY(mouse.x, mouse.y);
	charAt = Character.GetAtScreenXY(mouse.x, mouse.y);
	invAt = InventoryItem.GetAtScreenXY(mouse.x, mouse.y);
  // get location under mouse cursor
  GSloctype = GetLocationType (mouse.x, mouse.y);

  if (GSloctype == 1)
		GSlocid = hotAt.ID;
  else if (GSloctype == 2)
		GSlocid = charAt.ID;
  else if (GSloctype == 3)
		GSlocid = objAt.ID;
  else if ( null != invAt )
		GSlocid = invAt.ID;


	GSlocname = Game.GetLocationName (mouse.x, mouse.y);

  GSagsusedmode = Mouse.Mode;
  used_action = global_action;

	if (IsGamePaused () == 1)
  {
    // Game is paused, so do nothing (ie. don't allow mouse click)
  }
  else if ( gMaps.Visible )
  {
    // if map
    if (button == eMouseLeft)
    {
      if (IsInteractionAvailable (mouse.x, mouse.y, eModeUseinv))
				ProcessClick (mouse.x, mouse.y, eModeUseinv); //MODE_USE
      else
				ProcessClick (mouse.x, mouse.y, eModeWalkto);
    }
  }
  //end if map
  else if (button == eMouseLeft)
  {
    if ( GlobalCondition(2) || GlobalCondition(3) || GlobalCondition(4) )
    {
    }
    else if ( GSagsusedmode == 9 )
    {
			gAktionText.TextColor = ActionLabelColorHighlighted;

			if ( IsInteractionAvailable(mouse.x, mouse.y, GSagsusedmode) )
			{
				ProcessClick(mrx - GetViewportX(), mry - GetViewportY(), GSagsusedmode);
			}
      else
			{
				ProcessClick(mrx - GetViewportX(), mry - GetViewportY(), eModeWalkto);
			}
    }
    else if ( (GSagsusedmode == eModeTalkto) && (IsInteractionAvailable(mouse.x, mouse.y, GSagsusedmode) == 1) )
    {
			gAktionText.TextColor = ActionLabelColorHighlighted;

			//if ( GoToCharacter(charAt, 0, 1, 2) )
			//{
				charAt.RunInteraction(GSagsusedmode);
			//}
      SetAction(eActDefault);
		}
    else
    {
      UpdateActionBar();
      gAktionText.TextColor = ActionLabelColorHighlighted;
      ProcessClick(mrx - GetViewportX(), mry - GetViewportY(), GSagsusedmode);
      SetAction(eActDefault);
    }
  }
  //end if button left
  else if (button == eMouseRight)
  {
    if (alternative_action == eActDefault)
    {
      SetAction (eActDefault);
      gAktionText.TextColor = ActionLabelColorHighlighted;
      if (Mouse.Mode == 9) ProcessClick (mrx - GetViewportX (), mry - GetViewportY (), eModeWalkto);
      else ProcessClick (mrx - GetViewportX (), mry - GetViewportY (), Mouse.Mode );
    }
    else
    {
      SetAction (alternative_action);
      used_action = global_action;
      UpdateActionBar ();
      gAktionText.TextColor = ActionLabelColorHighlighted;
      GSagsusedmode = Mouse.Mode;
			
      if ((GSagsusedmode == eModeTalkto) && (IsInteractionAvailable (mouse.x, mouse.y, GSagsusedmode) == 1) && (charAt.ID < 7))
      {
        //if (GoToCharacter (charAt, 0, 1, 2))
					if ( null != charAt )
						charAt.RunInteraction(GSagsusedmode);
      }
      else ProcessClick (mrx - GetViewportX (), mry - GetViewportY (), GSagsusedmode);
      SetAction (eActDefault);
    }
  }
  else if (button == eMouseLeftInv)
  {
    //left click in inventory
    if (GlobalCondition (1))
    {
      // if the mouse is in the inventory and modes Walk or pickup are selected
      SetAction (eActUse);

      if ((GSinvloc.Extension() == 'u') && ( invAt.IsInteractionAvailable(eModeInteract) == 1 ))
      {
        // use it immediately (not with anything else)
        used_action = global_action;
				if ( null != invAt )
					invAt.RunInteraction(eModeInteract);
        SetAction (eActDefault);
      }
      else
      {
				if ( null != invAt )
					player.ActiveInventory = invAt;
      }
    }
    else  if (GlobalCondition (2) == 1)
    {
      // if the mode is useinv and the mouse is over the active inv (like "use knife on knife")
    }
    else
    {
      used_action = global_action;
      if ( Mouse.Mode == 2 )
      {
        if (isAction (eActUse) && invAt.IsInteractionAvailable(eModeInteract) == 1) // if (isAction (eActUse) && invAt.IsInteractionAvailable(eModeUseinv) == 1)
        {
          gAktionText.TextColor = ActionLabelColorHighlighted;
					if ( invAt )
						invAt.RunInteraction(eModeInteract); // eModeUseinv
          SetAction (eActDefault);
        }
        else player.ActiveInventory = invAt;
      }
      else
      {
        GSagsusedmode = Mouse.Mode;
        gAktionText.TextColor = ActionLabelColorHighlighted;
				if ( invAt )
					invAt.RunInteraction(Mouse.Mode);
        SetAction (eActDefault);
      }
		}
		/* diese Zeile ist neu und verhindert, dass der Mauscursor nach Anwahl eines
		   Inventargegenstandes springt und einen falschen Hotspotpunkt hat */
		Mouse.ChangeModeHotspot(eModeUseinv, 7, 7); 
  }
  else if (button == eMouseRightInv)
  {
    if (alternative_action == eActDefault)
    {
      SetAction (eActDefault);
    }
    else
    {
      SetAction (alternative_action);
      used_action = global_action;
      GSagsusedmode = Mouse.Mode;
      if (Mouse.Mode == 2)
      {
        if (isAction (eActUse) && invAt.IsInteractionAvailable(eModeUseinv) == 1) //IsInventoryInteractionAvailable (GSlocid, MODE_USE) == 1)
        {
          UpdateActionBar ();
          gAktionText.TextColor = ActionLabelColorHighlighted;
					if ( invAt )
						invAt.RunInteraction(eModeUseinv);
          SetAction (eActDefault);
        }
        else player.ActiveInventory = invAt;
      }
      else
      {
        UpdateActionBar ();
        gAktionText.TextColor = ActionLabelColorHighlighted;
				if ( invAt )
					invAt.RunInteraction(Mouse.Mode);
				SetAction (eActDefault);
      }
    }
  }
}


// ============================= repeatedly_execute ===========================================
// this section after on_mouse_click

function repeatedly_execute ()
{
	DisplaySpeechQ_RE(); // place it before any other script code in rep. exec.
  
  if (IsGamePaused () != 1)
  {
    CheckTimers ();
		InventoryItem *invAt = InventoryItem.GetAtScreenXY(mouse.x, mouse.y);
    // --- for the MovePlayer function ---
    if (GScancelable == 1)
    {
      GScancelable = 0;
      if ( null == invAt ) on_mouse_click (eMouseLeft);
      else on_mouse_click (eMouseLeftInv);
    }
    else if (GScancelable == 2)
    {
      GScancelable = 0;
      CheckDefaultAction ();
      if ( null == invAt ) on_mouse_click (eMouseRight);
      else on_mouse_click (eMouseRightInv);
    }
    CheckDefaultAction ();
    UpdateActionBar ();
  }
  // change the arrows in the inventory to show if you
  // can scroll the inventory:
	//readonly InventoryItem* InvWindow.ItemAtIndex[];

	InvWindow *invMain = gMainInventory;
	if ( null != invMain.ItemAtIndex[0] )
	{
		if ( 0 != gMainInventory.TopItem )
		{
			// if inventory can scroll up
#ifdef SCROLL_INVENTORY
      int visible_items = (invMain.Width / invMain.ItemWidth) * (invMain.Height / invMain.ItemHeight);
      if ( invMain.ItemCount > visible_items ) // Hier wird nur nachfolgende Zeile ausgeführt, wenn das Inventar automatisch gescrollt werden soll
#endif
        gMainInvUp.NormalGraphic = invUparrowONsprite;
        
#ifdef SCROLL_INVENTORY
      InventoryItem *invItem = InventoryItem.GetAtScreenXY(180, 190);

      if ( null == invItem )
      {
        gMainInventory.ScrollUp();
      }
#endif
#ifndef SCROLL_INVENTORY
			InventoryItem *invItem = InventoryItem.GetAtScreenXY(180, 160);
		
      if ( null == invItem )
      {
      }
      else if (invItem.ID < 0)
      {
				gMainInventory.ScrollUp();
      }
#endif
		}
		else
    {
			gMainInvUp.NormalGraphic = invUparrowOFFsprite;
    }
	}
	if ( (gMainInventory.TopItem + (gMainInventory.ItemsPerRow * gMainInventory.RowCount)) < gMainInventory.ItemCount )
  {
		gMainInvDown.NormalGraphic = invDownarrowONsprite;
  }
  else
  {
		gMainInvDown.NormalGraphic = invDownarrowOFFsprite;
  }
  
  // Custom Code *****************************************
  // ================= Newspaper ========================
  // This lines will close the newspaper if the player clicks outside btNewspaper.
  if (btNewspaper.Visible == true)
  {
    if (mouse.IsButtonDown(eMouseLeft))
    {
      if ((mouse.x < btNewspaper.X || mouse.x > (btNewspaper.X + btNewspaper.Width)) || (mouse.y < btNewspaper.Y || mouse.y > (btNewspaper.Y + btNewspaper.Height)))
      {
        gNewspaper.Visible = false;
      }
    }
  }
  // =====================================================
  // *****************************************************
}


// ============================= on_key_press ===========================================
function on_key_press (int keycode)
{
  // called when a key is pressed. keycode holds the key's ASCII code
  // --- PAUSE-GUI ---
  if (keycode == 32)
  {
    // SPACEBAR
    if (IsGamePaused () == 0)
    {
      gPaused.Visible = true;
      DisableInterface ();
    }
    else
    {
      gPaused.Visible = false;
      EnableInterface ();
    }
  }
  // --- RESTART-GUI ---
  else if ( gRestart.Visible )
  {
    // if restart gui is on
    if ((keycode == key_u_no) || (keycode == key_l_no)) gRestart.Visible = false; // if N is pressed continue
    if ((keycode == key_u_yes) || (keycode == key_l_yes)) RestartGame (); // if Y is pressed restart game
  }
  // --- QUITGAME-GUI ---
  else if ( gConfirmexit.Visible )
  {
    // if exit gui is on
    if ((keycode == key_u_no) || (keycode == key_l_no)) gConfirmexit.Visible = false; // if N is pressed continue
    if ((keycode == key_u_yes) || (keycode == key_l_yes)) QuitGame (0);       // if Y is pressed quit game
  }
  if ( IsGamePaused () == 1 ) keycode = 0;  // game paused, so don't react to keypresses
  // --- Switch Players ---
  
  if ( keycode == eKeyF5    ) gOptions.Visible = true;
  if ( keycode == eKeyF8    ) gRestart.Visible = true;
  if ( keycode == eKeyCtrlC ) gConfirmexit.Visible = true;
  if ( keycode == eKeyF12   ) SaveScreenShot ("scrnshot.bmp");

#ifdef HIDDEN_DEBUG_ENABLED // spezielles Debugverhalten
	if ( keycode == eKeyCtrlS && null != debugfile ) Debug(0,0); // give all inventory
	if ( keycode == eKeyCtrlV && null != debugfile ) Debug(1,0); // version
	if ( keycode == eKeyCtrlA && null != debugfile ) Debug(2,0); // show walkable areas
	if ( keycode == eKeyCtrlX && null != debugfile ) Debug(3,0); // teleport to room
	// Debug 4 ist noch möglich (fps)
#endif
#ifndef HIDDEN_DEBUG_ENABLED // normals Debugverhalten
	if ( keycode == eKeyCtrlS ) Debug(0,0); // give all inventory
	if ( keycode == eKeyCtrlV ) Debug(1,0); // version
	if ( keycode == eKeyCtrlA ) Debug(2,0); // show walkable areas
	if ( keycode == eKeyCtrlX ) Debug(3,0); // teleport to room
  if ( keycode == eKeyCtrlB ) if (player.ActiveInventory) player.Say(player.ActiveInventory.Name); else player.Say("Nullometer.");
#endif

  // --- triggering actions by the keys:---
  int action = 0;
  while (action < eActCount)
  {
    if ((keycode == action_l_keycode [action]) || (keycode == action_u_keycode [action]))
    {
      SetAction (action);
      action = eActCount;
    }
    else
    {
      action++;
    }
  }
}

// gMain
function gMainInvUp_OnClick(GUIControl *control, MouseButton button)
{
	if ( gOptions.Visible || gRestore.Visible || gSave.Visible ) 
	{ 
		// disable GUI, when other GUI is on
	}
	else if (gMainInventory.TopItem > 0)
	{
		gMainInventory.ScrollUp();
	}
}

function gMainInvDown_OnClick(GUIControl *control, MouseButton button)
{
	if ( gOptions.Visible || gRestore.Visible || gSave.Visible ) 
	{ 
		// disable GUI, when other GUI is on
	}
	else if ((gMainInventory.TopItem + gMainInventory.ItemsPerRow + gMainInventory.RowCount) < gMainInventory.ItemCount) //game.top_inv_item < game.num_inv_items - game.num_inv_displayed)
	{
		gMainInventory.ScrollDown();
	}
}

function gMainGive_OnClick(GUIControl *control, MouseButton button)
{
	SetAction (button_action [0]);
}

function gMainPickup_OnClick(GUIControl *control, MouseButton button)
{
	SetAction (button_action [1]);
}

function gMainUse_OnClick(GUIControl *control, MouseButton button)
{
	SetAction (button_action [2]);
}

function gMainOpen_OnClick(GUIControl *control, MouseButton button)
{
	SetAction (button_action [3]);
}

function gMainLookat_OnClick(GUIControl *control, MouseButton button)
{
	SetAction (button_action [4]);
}

function gMainPush_OnClick(GUIControl *control, MouseButton button)
{
	SetAction (button_action [5]);
}

function gMainClose_OnClick(GUIControl *control, MouseButton button)
{
	SetAction (button_action [6]);
}

function gMainTalkto_OnClick(GUIControl *control, MouseButton button)
{
	SetAction (button_action [7]);
}

function gMainPull_OnClick(GUIControl *control, MouseButton button)
{
	SetAction (button_action [8]);
}

function gMaingui_OnClick(GUI *theGui, MouseButton button)
{
	SetAction (button_action [button]);
}

// gOptions
function gOptSave_OnClick(GUIControl *control, MouseButton button)
{
	gOptions.Visible = false;
	gSave.GetLucasSavegameListBox(lstSave);
	gSave.Visible = true;
}

function gOptLoad_OnClick(GUIControl *control, MouseButton button)
{
	gOptions.Visible = false;
	gRestore.GetLucasSavegameListBox(lstRestore);
	gRestore.Visible = true;
}

function gOptPlay_OnClick(GUIControl *control, MouseButton button)
{
	gOptions.Visible = false;
}

function gOptExit_OnClick(GUIControl *control, MouseButton button)
{
	gConfirmexit.Visible = true;
}

// gRestore
function gRstCancel_OnClick(GUIControl *control, MouseButton button)
{
	gRestore.Visible = false;
}

function lstRestore_OnSelectionChanged(GUIControl *control)
{
	int index = lstRestore.SelectedIndex;
	if ( null != Game.GetSaveSlotDescription (index + 100) )
	{
		gRestore.Visible = false;
		RestoreGameSlot (index + 100);
	}
}

function gRstUp_OnClick(GUIControl *control, MouseButton button)
{
	if (GStopsaveitemRestore < 5)
		GStopsaveitemRestore = 0;
	else GStopsaveitemRestore -= 5;
		lstRestore.TopItem = GStopsaveitemRestore;
}

function gRstDown_OnClick(GUIControl *control, MouseButton button)
{
	if ( GStopsaveitemRestore < 95 )
 	{
		GStopsaveitemRestore += 5;
		lstRestore.TopItem = GStopsaveitemRestore;
 	}
}

// gSave
function lstSave_OnSelectionChanged(GUIControl *control)
{
	String	sDescription;
	int		  stbypos;
	int		  index			    = lstSave.SelectedIndex;
	sDescription			    = String.Format("%d. ", index + 1);
	gSaveTextBoxlbl.Text	= sDescription;

	sDescription          = Game.GetSaveSlotDescription(index + 100);

	if ( null == sDescription )
	{
		sDescription = "";
	}

	gSaveTextBox.Text = sDescription;
	gSaveTextBox.SetPosition(GetTextWidth(gSaveTextBoxlbl.Text, gSaveTextBoxlbl.Font) - 1, - 1);

	int x = gSave.X + lstSave.X + gSaveTextBoxlbl.X;
	int y = gSave.Y + lstSave.Y + ((index - lstSave.TopItem) * gSavetextbox.Height + 1);

	gSavetextbox.SetPosition(x, y);
  gSavetextbox.Visible = true;
}

function gSaveSave_OnClick(GUIControl *control, MouseButton button)
{
	String buffer;
	int index = lstSave.SelectedIndex;
	if ( index >= 0 )
	{
		buffer = gSaveTextBox.Text;
		gSave.Visible = false;
		gSavetextbox.Visible = false;
		SaveGameSlot (index + 100, buffer);
	}
}

function gSaveUp_OnClick(GUIControl *control, MouseButton button)
{
 	gSavetextbox.Visible = false;

  if (GStopsaveitemSave < 5)
  {
		GStopsaveitemSave = 0;
  }
	else
  {
		GStopsaveitemSave -= 5;
  }

  lstSave.TopItem = GStopsaveitemSave;

  if ( lstSave.SelectedIndex >= lstSave.TopItem && lstSave.SelectedIndex <= lstSave.TopItem + 8 )
  {
    lstSave_OnSelectionChanged(control);
  }
}

function gSaveDown_OnClick(GUIControl *control, MouseButton button)
{
	gSavetextbox.Visible = false;

  if ( GStopsaveitemSave < 95 )
  {
    GStopsaveitemSave += 5;
    lstSave.TopItem = GStopsaveitemSave;
  }

  if ( lstSave.SelectedIndex >= lstSave.TopItem && lstSave.SelectedIndex <= lstSave.TopItem + 8 )
  {
    lstSave_OnSelectionChanged(control);
  }
}


function gSaveAbbruch_OnClick(GUIControl *control, MouseButton button)
{
	gSave.Visible = false;
	gSavetextbox.Visible = false;
}

// gSavetextbox
function gSavetextbox_OnClic(GUI *theGui, MouseButton button)
{
	if (button == eMouseRight)
		gSavetextbox.Visible = false;
}

function gSaveTextBox_OnActivate(GUIControl *control)
{
	int index = lstSave.SelectedIndex;
	gSave.Visible = false;
	gSavetextbox.Visible = false;
	SaveGameSlot (index + 100, gSaveTextBox.Text);
}

// gConfirm
function gConfirmYes_OnClick(GUIControl *control, MouseButton button)
{
	QuitGame (0);
}

function gConfirmNo_OnClick(GUIControl *control, MouseButton button)
{
	gConfirmexit.Visible = false;
}

function SayIfAction(this Character*, eAction action, String message)
{
	if ( UsedAction(action) )
		this.Say(message);
}

bool SayIfPlayer(this Character*, String message)
{
	if ( player == this )
	{
		player.Say(message);
		return true;
	}
	return false;
}


#sectionstart on_event  // DO NOT EDIT OR REMOVE THIS LINE
function on_event (int event, int data)
{
	if (event == eEventLeaveRoom)
	{
		qStopSpeech();
	}

  if (event == eEventRestoreGame)
  {
    AdjustLanguage();
    CallRoomScript(GAME_RESTORED);
  }

	if ((event == eEventEnterRoomBeforeFadein) || (event == eEventRestoreGame))
  {
    player.PlaceOnWalkableArea();
  }
}
#sectionend on_event  // DO NOT EDIT OR REMOVE THIS LINE


#sectionstart dialog_request  // DO NOT EDIT OR REMOVE THIS LINE
function dialog_request (int param)
{
  if (param == 1) // Clouso drops his phone.
  {
    cClou.FaceDirection(eDirUp);
    Wait(5);
    cClou.ChangeRoom(0);
    object[2].Visible=false;
    aSound3.Play();
    ControllMode(true, true);
    Mouse.Visible = true; gMaingui.Visible = true; gAction.Visible = true;
  }
  else if (param == 2) // Syd is asking Jeff about Britney's Diary.
  {
    if (player.HasInventory(iPortemonnaie)) // Syd got his Portemonnaie.
    {
      StartCutscene(eSkipESCOrRightButton);
      dJeff.SetOptionState(2, eOptionOff);
      dJeff.SetOptionState(1, eOptionOff);
      player.Say("Natürlich habe ich Geld dabei.");
      player.Say("Nebenbei, hast du die \"Ware\" bekommen?");
      cJeff.Say("Du interessiert dich nicht besonders für das Weltgeschehen, oder?");
      player.Say("Wieso fragst du?");
      cJeff.Say("Heute schon in die Zeitung gekuckt?");
      cJeff.LockView(JEFFZEITUNG);
      cJeff.Animate(0, 5, eOnce, eBlock, eForwards);
      Wait(10);
      EndCutscene();
      
      StartCutscene(eSkipESCOrRightButton);
      SetAdditionalGuiTranslated(1); // GUI Translated 
      gNewspaper.Visible = true;
      Wait(300);
      gNewspaper.Visible = false;
      EndCutscene();
      
      StartCutscene(eSkipESCOrRightButton);
      Wait(5);
      cJeff.Animate(0, 5, eOnce, eBlock, eBackwards);
      cJeff.UnlockView();
      Wait(5);
      player.Say("Die Zeitung schreibt doch sowieso nur Müll.");
      cJeff.Say("Ich wäre mir da nicht so sicher.");
      cJeff.Say("An deiner Stelle würde ich mich damit beeilen, wenn du dir noch eine Ausgabe zulegen willst.");
      player.Say("Weißt du was? Das werde ich jetzt auch machen. Schnell die Kontaktdaten vom Verlag besorgen und eine Ausgabe bestellen.");
      player.Walk(308, 134, eBlock, eWalkableAreas);
      player.Transparency=100; // Syd becomes invisible, so that it looks like he already left the room.
      cJeff.FaceDirection(eDirRight);
      cJeff.Say("Und was ist mit deiner Pizza?");
      jeffTalk++;
      player.ChangeRoom(7, 11, 131);
      player.FaceDirection(eDirRight);
      player.Transparency=0; // Syd becomes visible again, so that he is still there after the room change.
      ControllMode(true, true);
      EndCutscene();
    }
    else // Syd hasn't got his Portemonnaie yet.
    {
      player.Say("Ähmmm....kannst du es mir nicht anschreiben?");
      cJeff.Say("Tut mir leid, Syd. Ich kann dir keinen Kredit geben.");
      cJeff.Say("Komm wieder, wenn du etwas Geld dabei hast.");
      ControllMode(true, true);
    }
  }
  else if (param == 3) // GUI is turned on again.
  {
    ControllMode(true, true);
  }
  else if (param == 4) // Syd and Jeff talk about the ban of Britney's Diaries.
  {
    dJeff.SetOptionState(5, eOptionOff);
    cJeff.FaceDirection(eDirLeft);
    cJeff.Say("Ach deshalb...");
    player.Say("...");
    player.Say("Deshalb was?");
    cJeff.FaceDirection(eDirDown);
    cJeff.Say("Kennst du Tom Koslowski?");
    player.Say("Koslowski? Mr. Koslowski? Unser Lehrer?");
    cJeff.Say("Sein Sohn.");
    cJeff.Say("Er ist hier gerade mit einem Haufen Büchern vorbeigelaufen.");
    cJeff.Say("Wahrscheinlich vertickt der Depp die jetzt zu völlig utopischen Preisen.");
    player.Say("Momentmal. Der Sohn von Kotzlowski betreibt Schwarzhandel?");
    cJeff.Say("Der Kerl hat wenig mit seinem Vater gemeinsam.");
    cJeff.Say("Am wenigsten der Intellekt. Der Depp ist völlig zurückgeblieben. Hat was von Ed.");
    player.Say("Und das bei dem Vater.");
    cJeff.Say("Kommt in den besten Familien vor.");
    dTom.SetOptionState(1, eOptionOff);
    dTom.SetOptionState(2, eOptionOn);
    jeffTalk++;
  }
  else if (param == 5) // Britney turns to the hamster cage and the GUI becomes visible again.
  {
    cBritney.FaceDirection(eDirUp);
    ControllMode(true, true);
  }
  else if (param == 6) // Scene with the two old Jeff lookalikes.
  {
    cNix.ChangeRoom(5,  160, 120);
    cNix.SetAsPlayer();
  }
  else if (param == 7) // Syd asked Britney why she is here.
  {
    if (cBritney.SpeechView == BRITNEYT)
    {
      cBritney.LockView(BRITNEYANGRY);
      cBritney.SpeechView = BRITNEYANGRY;
    }
  }
  else if (param == 8) // Syd asked Britney if she starring at the hamster.
  {
    if (cBritney.SpeechView != BRITNEYT)
    {
      cBritney.UnlockView();
      cBritney.SpeechView = BRITNEYT;
    }
  }
}
#sectionend dialog_request  // DO NOT EDIT OR REMOVE THIS LINE


#sectionstart unhandled_event  // DO NOT EDIT OR REMOVE THIS LINE
function unhandled_event (int xxx, int yyy)
{
	InventoryItem* invItem;
  int type = GSloctype;
  String locationname, usedinvname;

	String translation;
	translation = Game.TranslationFilename;

	invItem = InventoryItem.GetAtScreenXY(mouse.x, mouse.y);
  locationname = GSlocname.RemoveExtension();
	
	if ( null != invItem )
  if (invItem.ID >= 0) type = 4;
  if (GSagsusedmode == 4)
  {
		int i = 0;
		invItem = player.ActiveInventory;
		if ( null != invItem )
		{
		i = invItem.ID;
    if (i >= 0)
    {
      usedinvname = invItem.Name;
      usedinvname = usedinvname.RemoveExtension();
      if (type > 0) type += 4;
	}
	}
  }
  if (GSagsusedmode != 9 && type != 0)
  {
    //Check modes with: if(UsedAction(A_???)), check types by if(type==#). types:
    //1   a hotspot
    //2   a character
    //3   an object
    //4   an inventory item.
    //5   inv. item on hotspot
    //6   inv. item on character
    //7   inv. item on object
    //8   inv. item on inv. item
    // // You have the string "locationname" that is the name of
    // // what you clicked on, and the string "usedinvname" that is
    // // the name of the item that was used on where you clicked (only for types 5,6,7,8)
    // // REPLACE THIS SAMPLE INTERACTIONS WITH YOURS:

    if (type == 2 || type == 6) 
		{
			Character *charAt;
			charAt = Character.GetAtScreenXY(mouse.x,  mouse.y);
			if ( charAt )
			{
				player.FaceCharacter(charAt);
			}
		}

    if (UsedAction (eActClose))
    {
			cAchmed.SayIfPlayer("Wie sollen schließen das?");
      if ( cAchmed != player )
				player.Say("Besser nicht.");
    }
    else if (UsedAction (eActUse) && type >= 5)
    {
			cAchmed.SayIfPlayer("Passieren nichts.");
      if ( cAchmed != player )
				player.Say("Tja, scheint nicht zu klappen.");
    }
    else if (UsedAction (eActLookAt))
    {
			if ( cAchmed == player )
			{
				if ( GetGlobalInt(12) == 0 )
				{
					player.Say("Achmed nix können sehen was.");
					SetGlobalInt(12,1);
				}
				else if ( GetGlobalInt(12) == 1 )
				{ 
					player.Say("Achmed finden es blöd."); 
					SetGlobalInt(12,2); 
				}
				else if ( GetGlobalInt(12) == 2 ) 
				{
					player.Say("Was guckst du?!?");
					SetGlobalInt(12,3);
				}
				else if ( GetGlobalInt(12) == 3 ) 
				{ 
					player.Say("Nix sehen können!"); 
					SetGlobalInt(12,0); 
				}
			}
      else
			{
				player.Say("Toll.");
			}
    }
    else if ((UsedAction (eActPush)) || (UsedAction (eActPull)))
    {
			cAchmed.SayIfPlayer("Achmed können nicht alles bewegen oder was?!?");
      if ( cAchmed != player )
				player.Say("Da tut sich nichts.");
    }
    else if (UsedAction (eActPickUp))
    {
			cAchmed.SayIfPlayer("Achmed brauchen das nicht.");
      if ( cAchmed != player )			
				player.Say("Da bewegt sich nichts.");
    }
    else if (UsedAction (eActOpen))
    {
			cAchmed.SayIfPlayer("Achmed nicht können öffnen.");
      if ( cAchmed != player )			
				player.Say("Es scheint nicht aufzugehen.");
    }
    else if (UsedAction (eActTalkTo))
    {
      if (type == 2)
      {
				cAchmed.SayIfPlayer("Wollen nicht mit Achmed labern.");
				if ( cAchmed != player )				
					player.Say("Jetzt nicht.");
      }
      else
			{
				cAchmed.SayIfPlayer("Das sein nicht gut.");
				if ( cAchmed != player )
					player.Say("Das klappt so nicht.");
			}
    }
    else if (type == 4)
    {
			cAchmed.SayIfPlayer("Isse niche gute.");
      if ( cAchmed != player )			
				player.Say("Das klappt so nicht.");
    }
    else if (UsedAction (eActUse) || UsedAction (eActUseInventory))
    {
			cAchmed.SayIfPlayer("Klappen nicht.");
      if ( cAchmed != player )			
				player.Say("Besser nicht.");
    }
  }
}
#sectionend unhandled_event  // DO NOT EDIT OR REMOVE THIS LINE

////////////////////////////////////////////////////////////////////////////////////
function Unhandled()
{
  unhandled_event (0, 0);
}

function Unhandled_Inventory()
{
	if (UsedAction(eActPickUp))
	{
		Wait(5);
		player.Say("Das hab ich schon bei mir. Ich kann es nicht noch einmal aufnehmen.");
	}
	else if (UsedAction(eActPull))
	{
		Wait(5);
		player.Say("Wozu?");
	}
	else if (UsedAction(eActPush))
	{
		Wait(5);
		player.Say("Es bewegt sich nicht.");
	}
	else if (UsedAction(eActOpen))
	{
		Wait(5);
		player.Say("Das lässt sich nicht öffnen.");
	}
	else if (UsedAction(eActClose))
	{
		Wait(5);
		player.Say("Das lässt sich nicht schließen.");
	}
	else Unhandled();
}


function Unhandled_Character()
{
	if (UsedAction(eActWalkTo))
	{
	//	Wait(5);
	}
	else if (UsedAction(eActLookAt))
	{
		Wait(5);
		player.Say("Das ist jemand anderes.");
	}
	else if (UsedAction(eActPickUp))
	{
		Wait(5);
		player.Say("Zu schwer.");
	}
	else if (UsedAction(eActPull))
	{
		Wait(5);
		player.Say("Das bringt nichts.");
	}
	else if (UsedAction(eActPush))
	{
		Wait(5);
		player.Say("Das bringt nichts.");
	}
	else if (UsedAction(eActClose))
	{
		Wait(5);
		player.Say("Schließen? Gehts noch?");
	}
	else if (UsedAction(eActOpen))
	{
		Wait(5);
		player.Say("Öffnen? Gehts noch?");
	}
	else if (UsedAction(eActUse))
	{
		Wait(5);
		player.Say("Benutzen? Gehts noch?");
	}
  else if (UsedAction(eActGiveTo))
  {
    Wait(5);
    player.Say("Warum sollte ich das weitergeben?");
  }
	else Unhandled();
}

export GSPlayerUp, GSPlayerDown;
export debugfile;

// ==================== Misc. functions =========================



// ===================== Character functions ====================

function cJeff_AnyClick()
{
  if (any_click_move(62, 134, eDirUp))
  {
    if (UsedAction(eActLookAt))
    {
      Wait(5);
      player.Say("Das ist mein Kumpel Jeff.");
    }
    else if (UsedAction(eActUse))
    {
      Wait(5);
      player.Say("Mit was soll ich ihn benutzen?");
    }
    else if (UsedAction(eActPickUp))
    {
      Wait(5);
      player.Say("Jeff ist definitiv zu groß für meine Taschen.");
    }
    else if (UsedAction(eActOpen))
    {
      Wait(5);
      player.Say("Nein, danke. Auf den Anblick kann ich gerne verzichten.");
    }
    else if (UsedAction(eActClose))
    {
      Wait(5);
      player.Say("Das ergibt keinen Sinn.");
    }
    else if (UsedAction(eActGiveTo))
    {
      Wait(5);
      player.Say("Warum sollte ich ihm das geben?");
    }
    else if (UsedAction(eActPush))
    {
      Wait(5);
      player.Say("Ich möchte Jeff nicht umarmen.");
    }
    else if (UsedAction(eActPull))
    {
      Wait(5);
      player.Say("Soll ich ihn über die Theke ziehen, oder wie?");
    }
    else if (UsedAction(eActTalkTo))
    {
      cJeff.FaceDirection(eDirDown);
      if (jeffTalk == 1)
      {
       Wait(10);
       cJeff.Say("Da bist du ja wieder. Und? Hast du das Buch bestellt?");
       player.Say("Noch nicht.");
      }
      else
      {
        ControllMode(false, true);
        player.Say("Hi, Jeff.");
        cJeff.Say("Hi, Syd.");
        Wait(10);
        dJeff.Start();
      }
    }
    else if (UsedAction(eActUseInventory))
    {
      Wait(5);
      player.Say("Warum sollte ich ihm das geben?");
    }
    else Unhandled();
  }
}

function cTom_AnyClick()
{
  if (any_click_move(cTom.x-3, cTom.y+20, eDirUp))
  {
    if (UsedAction(eActTalkTo))
    {
      Wait(10);
      if (cEd.Room == cTom.Room) // Ed and Tom are negotiating.
      {
        player.FaceCharacter(cTom, eBlock);
        player.Say("Ihn jetzt anzusprechen bringt nichts.");
      }
      else // Ed isn't there yet or has already left.
      {
        ControllMode(false, true);
        dTom.Start();
      }
    }
    else if (UsedAction(eActLookAt))
    {
      Wait(10);
      if (jeffTalk == 2)
      {
        if (dTom.HasOptionBeenChosen(1))
        {
          player.Think("Das ist Tom. Keine Ahnung, wie sein Nachname lautet.");
        }else player.Think("Was ist denn das für ein abgewrackter Typ?");
      } else player.Think("Er sieht wirklich nicht so aus, als wäre er der Sohn von einem Lehrer.");
    }
    else if (UsedAction(eActGiveTo) || UsedAction(eActUseInventory))
    {
      Wait(5);
      player.Say("Warum sollte ich ihm das geben?");
    }
    else Unhandled();
  }
}

function cEd_AnyClick()
{
  if (any_click_move(cEd.x+40, cEd.y+5, eDirLeft))
  {
    if (UsedAction(eActLookAt))
    {
      Wait(5);
      player.Say("Das ist der verrückte Ed.");
    }
    else if (UsedAction(eActUse))
    {
      Wait(5);
      player.Say("Mit was soll ich ihn benutzen?");
    }
    else if (UsedAction(eActPickUp))
    {
      Wait(5);
      player.Say("Im Leben nicht!");
    }
    else if (UsedAction(eActOpen))
    {
      Wait(5);
      player.Say("Nein danke, auf den Anblick kann ich gut und gerne verzichten.");
    }
    else if (UsedAction(eActClose))
    {
      Wait(5);
      player.Say("Das ergibt keinen Sinn.");
    }
    else if (UsedAction(eActPull))
    {
      Wait(5);
      player.Say("Was sollte das bewirken?");
    }
    else if (UsedAction(eActPush))
    {
      Wait(5);
      player.Say("Ich bezweifel, dass ich ihn umstoßen könnte.");
    }
    else if (UsedAction(eActTalkTo))
    {
      if (cEd.Room == cTom.Room) // Ed and Tom are negotiating.
      {
        player.Say("Ihn jetzt anzusprechen bringt nichts.");
      }
      else // Ed is searching for his missing hamster.
      {
        ControllMode(false, true);
        player.Say("Hallo Ed.");
        cEd.FaceCharacter(player, eBlock);
        cEd.Say("Oh. Hallo Syd.");
        dEd.Start();
      }
    }
    else if (UsedAction(eActGiveTo) || UsedAction(eActUseInventory))
    {
      Wait(5);
      if (cEd.Room == 7)
      {
        if (player.ActiveInventory == iHamster)
        {
          Mouse.Visible = false; gMaingui.Visible = false; gAction.Visible = false;
          if (iHamster.Graphic == 729) // The hamster is still alive.
          {
            player.Say("Hey Ed, ich habe deinen Hamster gefunden.");
            cEd.FaceCharacter(cSyd, eBlock);
            aSound4.Play();
            player.LoseInventory(iHamster);
            edExpressions(eNormal);
            cEd.Say("Vielen, vielen, vielen, Dank, Syd.");
            cEd.Say("Ich weiß nicht, was ich ohne ihn machen würde.");
            cEd.Say("Als Belohnung kann ich nur das Buch geben.");
            aSound4.Play();
            player.AddInventory(iDiary);
            cEd.Say("Falls ich außer der Belohnung noch was machen kann, brauchst du nur was zu sagen.");
            player.Say("Ich komme auf dich zurück.");
          }
          else // Syd killed the hamster.
          {
            player.Say("Ed, ich habe deinen Hamster gefunden. Leider war er schon tot.");
            cEd.FaceCharacter(cSyd, eBlock);
            aSound4.Play();
            player.LoseInventory(iHamster);
            edExpressions(eRed);
            cEd.Say("WER WAR DAS?");
            player.Say("Inspektor Clouso. Er wohnt im 2. Stockwerk dieses Gebäudes.");
            cEd.Say("Hier ist die Belohung.");
            aSound4.Play();
            player.AddInventory(iDiary);
            cEd.Say("Aber jetzt muss ich weg.");
            cEd.Say("ICH MUSS JEMANDEN TÖTEN!");
            cEd.Walk(245, 98, eBlock, eWalkableAreas);
            cEd.ChangeRoom(0);
            Wait(5);
            player.Say("Das muss ich sehen!");
            player.Walk(245, 98, eBlock, eWalkableAreas);
          }
          Wait(5);          
          player.ChangeRoom(17);
        } else player.Say("Warum sollte ich ihm das geben?");
      }
      else player.Say("Warum sollte ich ihm das geben?");
    }
  }
}

function cBritney_AnyClick()
{
  if (any_click_move(cBritney.x+40, cBritney.y, eDirLeft))
  {
    if (UsedAction(eActLookAt))
    {
      Wait(5);
      player.Say("Britney, Bernards Schwester.");
    }
    else if (UsedAction(eActUse) || UsedAction(eActPickUp))
    {
      Wait(5);
      player.FaceDirection(eDirDown);
      player.Say("Wir sind hier nicht in einer Trash-Episode!");
    }
    else if (UsedAction(eActOpen) || UsedAction(eActPull))
    {
      Wait(5);
      player.Say("Ausziehen wäre fein.");
    }
    else if (UsedAction(eActClose))
    {
      Wait(5);
      player.Say("Das ergibt keinen Sinn.");
    }
    else if (UsedAction(eActPush))
    {
      Mouse.Visible = false; gMaingui.Visible = false; gAction.Visible = false;
      Wait(5);      
      player.LockView(SYDSWALLOW);
      player.SpeechView = -1;
      player.Think("Jetzt bloß nicht schüchtern sein!");
      Wait(20);
      player.Animate(1, 5, eOnce, eBlock, eForwards);
      Wait(20);
      player.UnlockView();
      player.SpeechView = SYDT;
      player.Say("Umarme mich, Britney!");
      
      cBritney.FaceCharacter(player, eBlock);
      cBritney.Say("NEIN!");
      cBritney.FaceDirection(eDirUp);
      Mouse.Visible = true; gMaingui.Visible = true; gAction.Visible = true;
    }
    else if (UsedAction(eActGiveTo) || UsedAction(eActUseInventory))
    {
      Wait(5);      
      if (player.ActiveInventory == iPhone)
      {
        if (dBritney.HasOptionBeenChosen(5)) // The player knows, that Britney is looking for a purple phone.
        {
          Mouse.Visible = false; gMaingui.Visible = false; gAction.Visible = false;
          player.Say("Britney, ich habe hier etwas für dich.");
          cBritney.FaceCharacter(cSyd, eBlock);
          if (iPhone.Graphic == 714) // The feature phone isn't purple.
          {
            cBritney.Say("Bist du farbenblind? Ich möchte ein LILA Handy!");
            cBritney.FaceDirection(eDirUp);
            player.Think("Zumindest das Sehzentrum ist in ihrem Hirn verhanden und funktioniert.");
          }
          else
          {
            cBritney.UnlockView();
            cBritney.SpeechView = BRITNEYT;
            cBritney.Say("EIN LILA HANDY!");
            cBritney.Say("Genau so eins wollte ich haben!");
            Wait(10);
            aSound4.Play();
            player.LoseInventory(iPhone);
            Wait(10);
            cBritney.Walk(315, 132, eBlock, eWalkableAreas);
            cBritney.ChangeRoom(0);
          }
          Mouse.Visible = true; gMaingui.Visible = true; gAction.Visible = true;
        } else player.Say("Warum sollte ich ihr das geben?"); // The standard reaction because the player doesn't know that Britney is looking for a purple phone.                  
      } else player.Say("Warum sollte ich ihr das geben?");
    }
    else if (UsedAction(eActTalkTo))
    {
      Wait(5);
      player.Say("Britney?");
      Wait(2);
      cBritney.FaceCharacter(player, eBlock);
      cBritney.Say("Ja?");
      ControllMode(false, true);
      dBritney.Start();
    }
  }
}

// ===================== Inventory functions ====================

// iFernbedienung functions ==================

function iFernbedienung_Look()
{
	player.Say("Die Fernbedienung des Fernsehers.");
}

function iFernbedienung_OtherClick()
{
	Unhandled_Inventory();
}

// iPortemonnaie functions ==========

function iPortemonnaie_Look()
{
  player.Say("Billigstes Lederimitat.");
}

function iPortemonnaie_OtherClick()
{
  Wait(5);
  if (UsedAction(eActOpen))
  {
    if (!player.HasInventory(iCashCard))
    {
      aSound37.Play();
      Wait(20);
      player.Say("Meine CashCard.");
      aSound4.Play();
      player.AddInventory(iCashCard);
      player.Say("Und ein paar Dollar.");
    } else player.Say("Da sind nur noch ein paar Dollar drin.");
  }
  else if (UsedAction(eActClose)) player.Say("Das ist schon zu.");
  else if (UsedAction(eActPush) || UsedAction(eActPush)) player.Say("Das ergibt wenig Sinn.");
  else Unhandled();
}

// iColor functions ========================

function iFarbeimer_Look()
{
  player.Say("Ein Eimer lila Farbe.");
}

function iFarbeimer_OtherClick()
{
  // 717 = closed graphic, 718 open graphic
  Wait(5);
  if (UsedAction(eActUse)) player.Say("Ich könnte etwas hinein tauchen...");
  else if (UsedAction(eActOpen))
  {
    if (iFarbeimer.Graphic == 717)
    {
      aSound85.Play();
      iFarbeimer.Graphic = 718;
      Wait(10);
      player.Say("Die Farbe ist nun offen.");
    } else player.Say("Die Farbe ist bereits offen.");
  }
  else if (UsedAction(eActClose))
  {
    if (iFarbeimer.Graphic != 717)
    {
      aSound46.Play();
      iFarbeimer.Graphic = 717;
      Wait(10);
      player.Say("Die Farbe ist jetzt wieder zu.");
    } else player.Say("Die Farbe ist bereits zu.");
  }
  else if (UsedAction(eActPull) || UsedAction(eActPush)) player.Say("Es bringt nichts, wenn ich den Eimer bewege.");  
}

function iFarbeimer_UseInv()
{
  if (player.ActiveInventory == iPhone)
  {
    Wait(5);
    if (iPhone.Graphic == 714)
    {
      bool wasOpen;
      if (iFarbeimer.Graphic == 717)
      {
        aSound85.Play();
        iFarbeimer.Graphic = 718;
        Wait(10);
        wasOpen = true;
      }
      player.Say("Und rein damit.");
      aSound33.Play();
      iPhone.Graphic = 715;
      Wait(20);
      if (wasOpen)
      {
        Wait(10);
        aSound46.Play();
        iFarbeimer.Graphic = 717;
        Wait(10);
      }
    } else player.Say("Ich habe das Handy bereits gefärbt.");
  }
  else if (player.ActiveInventory == iHamster)
  {
    Wait(5);
    if (bMicrowave)
    {
      if (iHamster.Graphic == 729) // The hamster is still alive.
      {
        player.Say("Das macht zuviel Sauerei.");
      } else player.Say("Der Hamster ist doch schon tot.");
    } else player.Say("Ich verstehe nicht, was das bezwecken soll.");
  } else Unhandled_Inventory();
}

// iPhone functions ==========

function iPhone_Interact()
{
  Wait(5);
  player.Say("Es ist gesperrt und ich kenne den PIN nicht.");
}

function iPhone_Look()
{
  if (iPhone.Graphic == 714) player.Say("Ein Handy. Gehört eigentlich dem Inspektor.");
  else player.Say("Das Handy des Inspektors. In lila!");
}

function iPhone_OtherClick()
{
  Wait(5);
  if (UsedAction(eActOpen)) player.Say("Nicht mein Fachgebiet. Das wäre etwas für Bernard.");
  else if (UsedAction(eActClose)) player.Say("Es ist doch bereits zu.");
  else if (UsedAction(eActPush)) player.Say("Ich kann wild auf den Tasten drauf rum drücken, aber es bringt nichts.");
  else if (UsedAction(eActPull)) player.Say("Ich möchte das Handy nicht kaputt machen.");  
}

function iPhone_UseInv()
{
  if (player.ActiveInventory == iFarbeimer)
  {
    Wait(5);
    if (iPhone.Graphic == 714)
    {
      bool wasOpen;
      if (iFarbeimer.Graphic == 717)
      {
        aSound85.Play();
        iFarbeimer.Graphic = 718;
        Wait(10);
        wasOpen = true;
      }
      player.Say("Und rein damit.");
      aSound33.Play();
      iPhone.Graphic = 715;
      Wait(20);
      if (wasOpen)
      {
        Wait(10);
        aSound46.Play();
        iFarbeimer.Graphic = 717;
        Wait(10);
      }
    } else player.Say("Ich habe das Handy bereits gefärbt.");
  } else Unhandled_Inventory();
}

// iCashCard functions ==========

function iCashCard_Look()
{
  player.Say("Meine CashCard.");
  player.Say("Hat ewig gebraucht, bis die mir endlich bewilligt wurde.");
}

// iSock functions =============

function iSock_Look()
{
  player.Say("Als ich die Socke gekauft habe, war sie noch weiß.");
  Wait(20);
  player.FaceDirection(eDirDown);
  player.Say("Ich habe sie versehentlich zusammen mit meiner Sammlung gelber Krawatten gewaschen.");
}

function iSock_UseInv()
{
  if (player.ActiveInventory == iGlas)
  {    
    if (iGlas.Graphic == 722) // Empty.
    {
      player.Say("Und rein da.");
      player.LoseInventory(iSock);
      iGlas.Graphic = 724;
    }
    else if (iGlas.Graphic == 723) // Milk.
    {
      aSound28.Play();
      player.LoseInventory(iSock);
      Wait(20);
      iGlas.Graphic = 725;
      Wait(5);
      player.Say("Ich fass es nicht. Das funktioniert wirklich.");
    }
    else if (iGlas.Graphic == 726) // Water.
    {
      player.Say("Vorher muss das Wasser raus.");
    }
  } 
  else player.Say("Diese Dinge kann ich nicht miteinander benutzen.");
}

// iGlas functions ===========

function iGlas_Look()
{
  if (iGlas.Graphic == 722) // Empty.
  {
    player.Say("Ein leeres Glas.");
  }
  else if (iGlas.Graphic == 723) // Milk.
  {
    player.Say("Ein Glas, bis zum Rand gefüllt mit Milch.");
  }
  else if (iGlas.Graphic == 725) // MSS,
  {
    player.Say("In dem Glas ist nun Milchsockensäure.");
  }
  else if (iGlas.Graphic == 726) // Water.
  {
    player.Say("Ein Glas, gefüllt mit Leitungswasser.");
  }
  else if (iGlas.Graphic == 724) // Sock.
  {
    player.Say("Ein Glas mit einer Socke darin.");
    Wait(10);
    player.Say("Auch wenns eher nach Urin aussieht.");
  }
}

function iGlas_OtherClick()
{
  Wait(5);
  if (UsedAction(eActUse)) player.Say("Mit was?");
  else if (UsedAction(eActOpen)|| UsedAction(eActPull)) player.Say("Den Deckel kann ich abmachen, wenn es nötig ist.");
  else if (UsedAction(eActClose)) player.Say("Der Deckel ist schon drauf.");
  else if (UsedAction(eActPush)) player.Say("Ich möchte das Glas nicht zerdrücken.");
}

function iGlas_UseInv()
{
  if (player.ActiveInventory == iMilk)
  {
    if (iGlas.Graphic == 722) // Empty.
    {
      aSound97.Play();
      Wait(20);
      iGlas.Graphic = 723;
      player.Say("Die leere Packung brauche ich nicht mehr.");
      player.LoseInventory(iMilk);
    }
    else if (iGlas.Graphic == 724) // Sock.
    {
      aSound97.Play();
      Wait(20);
      iGlas.Graphic = 725;
      Wait(5);
      player.Say("Ich fass es nicht. Das funktioniert wirklich.");
      player.Say("Die leere Packung brauche ich nicht mehr.");
      player.LoseInventory(iMilk);
    }
    else if (iGlas.Graphic == 726) // Water.
    {
      player.Say("Vorher muss das Wasser raus.");
    }
  }
  else if (player.ActiveInventory == iSock)
  {
    if (iGlas.Graphic == 722) // Empty.
    {
      player.Say("Und rein da.");
      player.LoseInventory(iSock);
      iGlas.Graphic = 724;
    }
    else if (iGlas.Graphic == 723) // Milk.
    {
      aSound28.Play();
      player.LoseInventory(iSock);
      Wait(20);
      iGlas.Graphic = 725;
      Wait(5);
      player.Say("Ich fass es nicht. Das funktioniert wirklich.");
    }
    else if (iGlas.Graphic == 726) // Water.
    {
      player.Say("Vorher muss das Wasser raus.");
    }
  }
  else if (player.ActiveInventory == iHamster)
  {
    Wait(5);
    if (bMicrowave)
    {
      if (iHamster.Graphic == 729) // The hamster is still alive.
      {
        if (iGlas.Graphic == 722) // Jar is empty.
        {
          player.Say("Das bringt nichts. Wenn ich den Hamster ertränken möchte, muss sich schon irgendetwas darin befinden.");
        }
        else if (iGlas.Graphic == 723) // Jar is filled with milk.
        {
          Mouse.Visible = false; gMaingui.Visible = false; gAction.Visible = false;
          player.Say("Und heb.");
          Wait(5);
          player.LockView(HAMSTERMILK);
          player.Animate(0, 5, eOnce, eBlock, eForwards);
          player.Animate(1, 5, eRepeat, eNoBlock, eForwards);
          Wait(200);
          player.Animate(1, 15, eOnce, eBlock, eForwards);
          Wait(50);
          player.Animate(2, 5, eOnce, eBlock, eForwards);
          Wait(20);
          player.UnlockView();
          player.FaceDirection(eDirDown);
          iHamster.Graphic = 730;
          Game.StopAudio(eAudioTypeMusic);
          player.Say("Armer kleiner Racker.");
          player.Say("Ist ganz friedlich ertrunken.");
          clousoDeath = 1;
          Mouse.Visible = true; gMaingui.Visible = true; 	gAction.Visible = true;
        }
        else if (iGlas.Graphic == 726) // Jar is filled with water.
        {
          Mouse.Visible = false; gMaingui.Visible = false; gAction.Visible = false;
          player.Say("Und heb.");
          Wait(5);
          player.LockView(HAMSTERWATER);
          player.Animate(0, 5, eOnce, eBlock, eForwards);
          player.Animate(1, 5, eRepeat, eNoBlock, eForwards);
          Wait(200);
          player.Animate(1, 15, eOnce, eBlock, eForwards);
          Wait(50);
          player.Animate(2, 5, eOnce, eBlock, eForwards);
          Wait(20);
          player.UnlockView();
          player.FaceDirection(eDirDown);
          iHamster.Graphic = 730;
          Game.StopAudio(eAudioTypeMusic);
          player.Say("Armer kleiner Racker.");
          player.Say("Ist ganz friedlich ertrunken.");
          clousoDeath = 1;
          Mouse.Visible = true; gMaingui.Visible = true; 	gAction.Visible = true;
        }
        else if (iGlas.Graphic == 725) // Jar contains milk sock acid.
        {
          Mouse.Visible = false; gMaingui.Visible = false; gAction.Visible = false;
          player.Say("Und heb.");
          Wait(5);
          player.LockView(HAMSTERACID);
          player.Animate(0, 5, eOnce, eBlock, eForwards);
          player.Animate(1, 5, eRepeat, eNoBlock, eForwards);
          Wait(200);
          player.Animate(1, 15, eOnce, eBlock, eForwards);
          Wait(50);
          player.Animate(2, 5, eOnce, eBlock, eForwards);
          Wait(20);
          player.UnlockView();
          player.FaceDirection(eDirDown);
          iGlas.Graphic = 722;
          Wait(100);
          iHamster.Graphic = 730;
          player.Say("Und deshalb sollte man die Milchsockensäure außerhalb der Reichweite von Kindern und Tieren aufbewahren.");
          clousoDeath = 2;
          Mouse.Visible = true; gMaingui.Visible = true; 	gAction.Visible = true;
        }
        else if (iGlas.Graphic == 724) // Jar contains sock.
        {
          player.Say("Was soll das denn? Mit einer Socke kann ich den Hamster nicht töten.");
        }
      } else player.Say("Der Hamster ist doch schon tot.");
    } else player.Say("Ich verstehe nicht, was das bezwecken soll.");
  } else player.Say("Warum sollte ich das in das Glas stecken?");
}

// iMilk functions ============

function iMilk_Look()
{
  player.Say("Eine Packung Frischmilch.");
}

function iMilk_OtherClick()
{
  Wait(5);
  if (UsedAction(eActUse)) player.Say("Mit was soll ich die Milch benutzen?");
  else if (UsedAction(eActOpen)) player.Say("Die Milch öffne ich erst, wenn ich sie auch brauche.");
  else if (UsedAction(eActClose)) player.Say("Die Packung ist noch zu.");
  else if (UsedAction(eActPull)) player.Say("Etwa durch die Nase ziehen?");
  else if (UsedAction(eActPush)) player.Say("Ich möchte die Packung nicht zerdrücken.");
}

function iMilk_UseInv()
{
  if (player.ActiveInventory == iGlas)
  {
    if (iGlas.Graphic == 722) // Empty.
    {
      aSound97.Play();
      Wait(20);
      iGlas.Graphic = 723;
      player.Say("Die leere Packung brauche ich nicht mehr.");
      player.LoseInventory(iMilk);
    }
    else if (iGlas.Graphic == 724) // Sock.
    {
      aSound97.Play();
      Wait(20);
      iGlas.Graphic = 725;
      Wait(5);
      player.Say("Ich fass es nicht. Das funktioniert wirklich.");
      player.Say("Die leere Packung brauche ich nicht mehr.");
      player.LoseInventory(iMilk);
    }
    else if (iGlas.Graphic == 726) // Water.
    {
      player.Say("Vorher muss das Wasser raus.");
    }
  } 
  else if (player.ActiveInventory == iHamster)
  {
    if (bMicrowave)
    {
      if (iHamster.Graphic == 729) // The hamster is still alive.
      {
        player.Say("Mit der Milchpackung ist das recht umständlich.");
      } else player.Say("Der Hamster ist doch schon tot.");
    } else player.Say("Ich verstehe nicht, was das bezwecken soll.");
  } else player.Say("Diese Dinge kann ich nicht miteinander benutzen.");
}

// iPills functions ======================

function iPills_Look()
{
  player.Say("Schlaftabletten.");
  Wait(5);
  player.FaceDirection(eDirDown);
  player.Say("Ich habe in letzter Zeit Probleme mit dem Einschlafen, ok?");
}

function iPills_UseInv()
{
  if (player.ActiveInventory == iHamster)
  {
    if (bMicrowave)
    {
      if (iHamster.Graphic == 729) // The hamster is still alive.
      {
        Mouse.Visible = false; gMaingui.Visible = false; 	gAction.Visible = false;
        player.FaceDirection(eDirDown);
        player.LockView(HAMSTERPILLS);
        player.SpeechView = HAMSTERPILLS;
        player.Say("Und jetzt mach Ahh!");
        Wait(5);
        player.Animate(1, 5, eOnce, eBlock, eForwards);
        player.Animate(2, 5, eRepeat, eNoBlock, eForwards);
        //aMariostar.Play(eAudioPriorityHigh, eOnce);
        Wait(150);
        player.StopMoving();
        player.UnlockView();
        player.FaceDirection(eDirDown);
        player.SpeechView = SYDT;
        iHamster.Graphic = 730;
        //Game.StopAudio(eAudioTypeMusic);
        Wait(20);
        player.Say("Armer kleiner Racker.");
        player.Say("Er ist ganz friedlich durch eine Überdosis gestorben.");
        clousoDeath = 3;
        Mouse.Visible = true; gMaingui.Visible = true; 	gAction.Visible = true;
      } else player.Say("Der Hamster ist doch schon tot.");
    } else player.Say("Ich möchte den Hamster in der Mikrowelle grillen und ihn nicht vergiften.");
  } else Unhandled();
}

// iHamster functions  ===================

function iHamster_Look()
{    
  if (iHamster.Graphic == 729) // Hamster is still alive.
  {
    player.Say("Eds Hamster.");
    Wait(5);
    player.Say("Ist ihm sicher eine Belohnung werd, wenn ich ihm den wiederbringe.");
    Wait(50);
    player.Say("Oder ich könnte ihn in die Mikrowelle stopfen.");
    Wait(50);
    player.Say("Nah, so böse bin ich nicht.");
    Wait(20);
    player.FaceDirection(eDirDown);
    player.Say("Oder doch?");
  } 
  else // Hamster is dead.
  {    
    player.Say("Eds Hamster. Tot!");
    Wait(20);
    player.Say("Das hänge ich dem Inspektor an!");
  }
}

function iHamster_UseInv()
{
  if (player.ActiveInventory == iPills)
  {
    if (bMicrowave)
    {
      if (iHamster.Graphic == 729) // The hamster is still alive.
      {
        Mouse.Visible = false; gMaingui.Visible = false; gAction.Visible = false;
        player.FaceDirection(eDirDown);
        player.LockView(HAMSTERPILLS);
        player.SpeechView = HAMSTERPILLS;
        player.Say("Und jetzt mach Ahh!");
        Wait(5);
        player.Animate(1, 5, eOnce, eBlock, eForwards);
        player.Animate(2, 5, eRepeat, eNoBlock, eForwards);
        //aMariostar.Play(eAudioPriorityHigh, eOnce);
        Wait(150);
        player.StopMoving();
        player.UnlockView();
        player.FaceDirection(eDirDown);
        player.SpeechView = SYDT;
        iHamster.Graphic = 730;
        //Game.StopAudio(eAudioTypeMusic);
        Wait(20);
        player.Say("Armer kleiner Racker.");
        player.Say("Er ist ganz friedlich durch eine Überdosis gestorben.");
        clousoDeath = 3;
        Mouse.Visible = true; gMaingui.Visible = true; 	gAction.Visible = true;
      } else player.Say("Der Hamster ist doch schon tot.");
    } else player.Say("Ich möchte den Hamster in der Mikrowelle grillen und ihn nicht vergiften.");
  }
  else if (player.ActiveInventory == iGlas)
  {
    Wait(5);
    if (bMicrowave)
    {
      if (iHamster.Graphic == 729) // The hamster is still alive.
      {
        if (iGlas.Graphic == 722) // Jar is empty.
        {
          player.Say("Das bringt nichts. Wenn ich den Hamster ertränken möchte, muss sich schon irgendetwas darin befinden.");
        }
        else if (iGlas.Graphic == 723) // Jar is filled with milk.
        {
          Mouse.Visible = false; gMaingui.Visible = false; gAction.Visible = false;
          player.Say("Und heb.");
          Wait(5);
          player.LockView(HAMSTERMILK);
          player.Animate(0, 5, eOnce, eBlock, eForwards);
          player.Animate(1, 5, eRepeat, eNoBlock, eForwards);
          Wait(200);
          player.Animate(1, 15, eOnce, eBlock, eForwards);
          Wait(50);
          player.Animate(2, 5, eOnce, eBlock, eForwards);
          Wait(20);
          player.UnlockView();
          player.FaceDirection(eDirDown);
          iHamster.Graphic = 730;
          Game.StopAudio(eAudioTypeMusic);
          player.Say("Armer kleiner Racker.");
          player.Say("Ist ganz friedlich ertrunken.");
          clousoDeath = 1;
          Mouse.Visible = true; gMaingui.Visible = true; 	gAction.Visible = true;
        }
        else if (iGlas.Graphic == 726) // Jar is filled with water.
        {
          Mouse.Visible = false; gMaingui.Visible = false; gAction.Visible = false;
          player.Say("Und heb.");
          Wait(5);
          player.LockView(HAMSTERWATER);
          player.Animate(0, 5, eOnce, eBlock, eForwards);
          player.Animate(1, 5, eRepeat, eNoBlock, eForwards);
          Wait(200);
          player.Animate(1, 15, eOnce, eBlock, eForwards);
          Wait(50);
          player.Animate(2, 5, eOnce, eBlock, eForwards);
          Wait(20);
          player.UnlockView();
          player.FaceDirection(eDirDown);
          iHamster.Graphic = 730;
          Game.StopAudio(eAudioTypeMusic);
          player.Say("Armer kleiner Racker.");
          player.Say("Ist ganz friedlich ertrunken.");
          clousoDeath = 1;
          Mouse.Visible = true; gMaingui.Visible = true; 	gAction.Visible = true;
        }
        else if (iGlas.Graphic == 725) // Jar contains milk sock acid.
        {
          Mouse.Visible = false; gMaingui.Visible = false; gAction.Visible = false;
          player.Say("Und heb.");
          Wait(5);
          player.LockView(HAMSTERACID);
          player.Animate(0, 5, eOnce, eBlock, eForwards);
          player.Animate(1, 5, eRepeat, eNoBlock, eForwards);
          Wait(200);
          player.Animate(1, 15, eOnce, eBlock, eForwards);
          Wait(50);
          player.Animate(2, 5, eOnce, eBlock, eForwards);
          Wait(20);
          player.UnlockView();
          player.FaceDirection(eDirDown);
          iGlas.Graphic = 722;
          Wait(100);
          iHamster.Graphic = 730;
          player.Say("Und deshalb sollte man die Milchsockensäure außerhalb der Reichweite von Kindern und Tieren aufbewahren.");
          clousoDeath = 2;
          Mouse.Visible = true; gMaingui.Visible = true; 	gAction.Visible = true;
        }
        else if (iGlas.Graphic == 724) // Jar contains sock.
        {
          player.Say("Was soll das denn? Mit einer Socke kann ich den Hamster nicht töten.");
        }
      } else player.Say("Der Hamster ist doch schon tot.");
    } else player.Say("Ich verstehe nicht, was das bezwecken soll.");
  }
  else if (player.ActiveInventory == iFarbeimer)
  {
    Wait(5);
    if (bMicrowave)
    {
      if (iHamster.Graphic == 729) // The hamster is still alive.
      {
        player.Say("Das macht zuviel Sauerei.");
      } else player.Say("Der Hamster ist doch schon tot.");
    } else player.Say("Ich verstehe nicht, was das bezwecken soll.");
  }
  else if (player.ActiveInventory == iMilk)
  {
    if (bMicrowave)
    {
      if (iHamster.Graphic == 729) // The hamster is still alive.
      {
        player.Say("Mit der Milchpackung ist das recht umständlich.");
      } else player.Say("Der Hamster ist doch schon tot.");
    } else player.Say("Ich verstehe nicht, was das bezwecken soll.");
  } 
  else player.Say("Diese Dinge kann ich nicht miteinander benutzen.");
}


function cAshley_AnyClick()
{
  if (any_click_move(210, 137, eDirUp))
  {
    if (UsedAction(eActLookAt))
    {
      Wait(5);
      player.Say("Das ist Ash. Ihm gehört der S-Mart.");
    }
    else if (UsedAction(eActUse))
    {
      Wait(5);
      player.Say("Ash lässt sich nicht ausnutzen.");
    }
    else if (UsedAction(eActPickUp))
    {
      Wait(5);
      player.Say("Er ist ein kleines bisschen zu groß für meine Taschen.");
    }
    else if (UsedAction(eActOpen))
    {
      Wait(5);
      player.Say("Auf den Anblick würde ich gerne verzichten!");
    }
    else if (UsedAction(eActClose))
    {
      Wait(5);
      player.Say("Das ergibt nicht wirklich Sinn.");
    }
    else if (UsedAction(eActGiveTo))
    {
      Wait(5);
      player.Say("Warum sollte ich ihm das geben?");
    }
    else if (UsedAction(eActPull))
    {
      Wait(5);
      player.Say("Ash lässt sich nicht über den Tisch ziehen.");
    }
    else if (UsedAction(eActPush))
    {
      Wait(5);
      player.Say("Ich möchte ihn wirklich nicht umarmen.");
    }
    else if (UsedAction(eActTalkTo))
    {
      Wait(5);
      player.Say("Ich wüsste nicht, worüber ich mit ihm reden sollte.");
    }
    else Unhandled();
  }
}
